import {
  __commonJS
} from "./chunk-76J2PTFD.js";

// node_modules/bluebird/js/browser/bluebird.js
var require_bluebird = __commonJS({
  "node_modules/bluebird/js/browser/bluebird.js"(exports, module) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.Promise = e();
      }
    }(function() {
      var define, module, exports;
      return function e(t, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof _dereq_ == "function" && _dereq_;
              if (!u && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f = new Error("Cannot find module '" + o2 + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o2] = { exports: {} };
            t[o2][0].call(l.exports, function(e2) {
              var n2 = t[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l, l.exports, e, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof _dereq_ == "function" && _dereq_;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var SomePromiseArray = Promise2._SomePromiseArray;
          function any(promises) {
            var ret2 = new SomePromiseArray(promises);
            var promise = ret2.promise();
            ret2.setHowMany(1);
            ret2.setUnwrap();
            ret2.init();
            return promise;
          }
          Promise2.any = function(promises) {
            return any(promises);
          };
          Promise2.prototype.any = function() {
            return any(this);
          };
        };
      }, {}], 2: [function(_dereq_2, module2, exports2) {
        "use strict";
        var firstLineError;
        try {
          throw new Error();
        } catch (e) {
          firstLineError = e;
        }
        var schedule = _dereq_2("./schedule");
        var Queue = _dereq_2("./queue");
        function Async() {
          this._customScheduler = false;
          this._isTickUsed = false;
          this._lateQueue = new Queue(16);
          this._normalQueue = new Queue(16);
          this._haveDrainedQueues = false;
          var self2 = this;
          this.drainQueues = function() {
            self2._drainQueues();
          };
          this._schedule = schedule;
        }
        Async.prototype.setScheduler = function(fn) {
          var prev = this._schedule;
          this._schedule = fn;
          this._customScheduler = true;
          return prev;
        };
        Async.prototype.hasCustomScheduler = function() {
          return this._customScheduler;
        };
        Async.prototype.haveItemsQueued = function() {
          return this._isTickUsed || this._haveDrainedQueues;
        };
        Async.prototype.fatalError = function(e, isNode2) {
          if (isNode2) {
            process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
            process.exit(2);
          } else {
            this.throwLater(e);
          }
        };
        Async.prototype.throwLater = function(fn, arg) {
          if (arguments.length === 1) {
            arg = fn;
            fn = function() {
              throw arg;
            };
          }
          if (typeof setTimeout !== "undefined") {
            setTimeout(function() {
              fn(arg);
            }, 0);
          } else
            try {
              this._schedule(function() {
                fn(arg);
              });
            } catch (e) {
              throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
            }
        };
        function AsyncInvokeLater(fn, receiver2, arg) {
          this._lateQueue.push(fn, receiver2, arg);
          this._queueTick();
        }
        function AsyncInvoke(fn, receiver2, arg) {
          this._normalQueue.push(fn, receiver2, arg);
          this._queueTick();
        }
        function AsyncSettlePromises(promise) {
          this._normalQueue._pushOne(promise);
          this._queueTick();
        }
        Async.prototype.invokeLater = AsyncInvokeLater;
        Async.prototype.invoke = AsyncInvoke;
        Async.prototype.settlePromises = AsyncSettlePromises;
        function _drainQueue(queue) {
          while (queue.length() > 0) {
            _drainQueueStep(queue);
          }
        }
        function _drainQueueStep(queue) {
          var fn = queue.shift();
          if (typeof fn !== "function") {
            fn._settlePromises();
          } else {
            var receiver2 = queue.shift();
            var arg = queue.shift();
            fn.call(receiver2, arg);
          }
        }
        Async.prototype._drainQueues = function() {
          _drainQueue(this._normalQueue);
          this._reset();
          this._haveDrainedQueues = true;
          _drainQueue(this._lateQueue);
        };
        Async.prototype._queueTick = function() {
          if (!this._isTickUsed) {
            this._isTickUsed = true;
            this._schedule(this.drainQueues);
          }
        };
        Async.prototype._reset = function() {
          this._isTickUsed = false;
        };
        module2.exports = Async;
        module2.exports.firstLineError = firstLineError;
      }, { "./queue": 26, "./schedule": 29 }], 3: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, debug) {
          var calledBind = false;
          var rejectThis = function(_, e) {
            this._reject(e);
          };
          var targetRejected = function(e, context) {
            context.promiseRejectionQueued = true;
            context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
          };
          var bindingResolved = function(thisArg, context) {
            if ((this._bitField & 50397184) === 0) {
              this._resolveCallback(context.target);
            }
          };
          var bindingRejected = function(e, context) {
            if (!context.promiseRejectionQueued)
              this._reject(e);
          };
          Promise2.prototype.bind = function(thisArg) {
            if (!calledBind) {
              calledBind = true;
              Promise2.prototype._propagateFrom = debug.propagateFromFunction();
              Promise2.prototype._boundValue = debug.boundValueFunction();
            }
            var maybePromise = tryConvertToPromise(thisArg);
            var ret2 = new Promise2(INTERNAL);
            ret2._propagateFrom(this, 1);
            var target = this._target();
            ret2._setBoundTo(maybePromise);
            if (maybePromise instanceof Promise2) {
              var context = {
                promiseRejectionQueued: false,
                promise: ret2,
                target,
                bindingPromise: maybePromise
              };
              target._then(INTERNAL, targetRejected, void 0, ret2, context);
              maybePromise._then(
                bindingResolved,
                bindingRejected,
                void 0,
                ret2,
                context
              );
              ret2._setOnCancel(maybePromise);
            } else {
              ret2._resolveCallback(target);
            }
            return ret2;
          };
          Promise2.prototype._setBoundTo = function(obj2) {
            if (obj2 !== void 0) {
              this._bitField = this._bitField | 2097152;
              this._boundTo = obj2;
            } else {
              this._bitField = this._bitField & ~2097152;
            }
          };
          Promise2.prototype._isBound = function() {
            return (this._bitField & 2097152) === 2097152;
          };
          Promise2.bind = function(thisArg, value) {
            return Promise2.resolve(value).bind(thisArg);
          };
        };
      }, {}], 4: [function(_dereq_2, module2, exports2) {
        "use strict";
        var old;
        if (typeof Promise !== "undefined")
          old = Promise;
        function noConflict() {
          try {
            if (Promise === bluebird)
              Promise = old;
          } catch (e) {
          }
          return bluebird;
        }
        var bluebird = _dereq_2("./promise")();
        bluebird.noConflict = noConflict;
        module2.exports = bluebird;
      }, { "./promise": 22 }], 5: [function(_dereq_2, module2, exports2) {
        "use strict";
        var cr = Object.create;
        if (cr) {
          var callerCache = cr(null);
          var getterCache = cr(null);
          callerCache[" size"] = getterCache[" size"] = 0;
        }
        module2.exports = function(Promise2) {
          var util = _dereq_2("./util");
          var canEvaluate2 = util.canEvaluate;
          var isIdentifier2 = util.isIdentifier;
          var getMethodCaller;
          var getGetter;
          if (false) {
            var makeMethodCaller = function(methodName) {
              return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
            };
            var makeGetter = function(propertyName) {
              return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
            };
            var getCompiled = function(name, compiler, cache) {
              var ret2 = cache[name];
              if (typeof ret2 !== "function") {
                if (!isIdentifier2(name)) {
                  return null;
                }
                ret2 = compiler(name);
                cache[name] = ret2;
                cache[" size"]++;
                if (cache[" size"] > 512) {
                  var keys = Object.keys(cache);
                  for (var i = 0; i < 256; ++i)
                    delete cache[keys[i]];
                  cache[" size"] = keys.length - 256;
                }
              }
              return ret2;
            };
            getMethodCaller = function(name) {
              return getCompiled(name, makeMethodCaller, callerCache);
            };
            getGetter = function(name) {
              return getCompiled(name, makeGetter, getterCache);
            };
          }
          function ensureMethod(obj2, methodName) {
            var fn;
            if (obj2 != null)
              fn = obj2[methodName];
            if (typeof fn !== "function") {
              var message = "Object " + util.classString(obj2) + " has no method '" + util.toString(methodName) + "'";
              throw new Promise2.TypeError(message);
            }
            return fn;
          }
          function caller(obj2) {
            var methodName = this.pop();
            var fn = ensureMethod(obj2, methodName);
            return fn.apply(obj2, this);
          }
          Promise2.prototype.call = function(methodName) {
            var args = [].slice.call(arguments, 1);
            ;
            if (false) {
              if (canEvaluate2) {
                var maybeCaller = getMethodCaller(methodName);
                if (maybeCaller !== null) {
                  return this._then(
                    maybeCaller,
                    void 0,
                    void 0,
                    args,
                    void 0
                  );
                }
              }
            }
            args.push(methodName);
            return this._then(caller, void 0, void 0, args, void 0);
          };
          function namedGetter(obj2) {
            return obj2[this];
          }
          function indexedGetter(obj2) {
            var index = +this;
            if (index < 0)
              index = Math.max(0, index + obj2.length);
            return obj2[index];
          }
          Promise2.prototype.get = function(propertyName) {
            var isIndex = typeof propertyName === "number";
            var getter;
            if (!isIndex) {
              if (canEvaluate2) {
                var maybeGetter = getGetter(propertyName);
                getter = maybeGetter !== null ? maybeGetter : namedGetter;
              } else {
                getter = namedGetter;
              }
            } else {
              getter = indexedGetter;
            }
            return this._then(getter, void 0, void 0, propertyName, void 0);
          };
        };
      }, { "./util": 36 }], 6: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, debug) {
          var util = _dereq_2("./util");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var async = Promise2._async;
          Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
            if (!debug.cancellation())
              return this._warn("cancellation is disabled");
            var promise = this;
            var child = promise;
            while (promise._isCancellable()) {
              if (!promise._cancelBy(child)) {
                if (child._isFollowing()) {
                  child._followee().cancel();
                } else {
                  child._cancelBranched();
                }
                break;
              }
              var parent = promise._cancellationParent;
              if (parent == null || !parent._isCancellable()) {
                if (promise._isFollowing()) {
                  promise._followee().cancel();
                } else {
                  promise._cancelBranched();
                }
                break;
              } else {
                if (promise._isFollowing())
                  promise._followee().cancel();
                promise._setWillBeCancelled();
                child = promise;
                promise = parent;
              }
            }
          };
          Promise2.prototype._branchHasCancelled = function() {
            this._branchesRemainingToCancel--;
          };
          Promise2.prototype._enoughBranchesHaveCancelled = function() {
            return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
          };
          Promise2.prototype._cancelBy = function(canceller) {
            if (canceller === this) {
              this._branchesRemainingToCancel = 0;
              this._invokeOnCancel();
              return true;
            } else {
              this._branchHasCancelled();
              if (this._enoughBranchesHaveCancelled()) {
                this._invokeOnCancel();
                return true;
              }
            }
            return false;
          };
          Promise2.prototype._cancelBranched = function() {
            if (this._enoughBranchesHaveCancelled()) {
              this._cancel();
            }
          };
          Promise2.prototype._cancel = function() {
            if (!this._isCancellable())
              return;
            this._setCancelled();
            async.invoke(this._cancelPromises, this, void 0);
          };
          Promise2.prototype._cancelPromises = function() {
            if (this._length() > 0)
              this._settlePromises();
          };
          Promise2.prototype._unsetOnCancel = function() {
            this._onCancelField = void 0;
          };
          Promise2.prototype._isCancellable = function() {
            return this.isPending() && !this._isCancelled();
          };
          Promise2.prototype.isCancellable = function() {
            return this.isPending() && !this.isCancelled();
          };
          Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
            if (util.isArray(onCancelCallback)) {
              for (var i = 0; i < onCancelCallback.length; ++i) {
                this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
              }
            } else if (onCancelCallback !== void 0) {
              if (typeof onCancelCallback === "function") {
                if (!internalOnly) {
                  var e = tryCatch2(onCancelCallback).call(this._boundValue());
                  if (e === errorObj2) {
                    this._attachExtraTrace(e.e);
                    async.throwLater(e.e);
                  }
                }
              } else {
                onCancelCallback._resultCancelled(this);
              }
            }
          };
          Promise2.prototype._invokeOnCancel = function() {
            var onCancelCallback = this._onCancel();
            this._unsetOnCancel();
            async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
          };
          Promise2.prototype._invokeInternalOnCancel = function() {
            if (this._isCancellable()) {
              this._doInvokeOnCancel(this._onCancel(), true);
              this._unsetOnCancel();
            }
          };
          Promise2.prototype._resultCancelled = function() {
            this.cancel();
          };
        };
      }, { "./util": 36 }], 7: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(NEXT_FILTER) {
          var util = _dereq_2("./util");
          var getKeys = _dereq_2("./es5").keys;
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          function catchFilter(instances, cb, promise) {
            return function(e) {
              var boundTo = promise._boundValue();
              predicateLoop:
                for (var i = 0; i < instances.length; ++i) {
                  var item = instances[i];
                  if (item === Error || item != null && item.prototype instanceof Error) {
                    if (e instanceof item) {
                      return tryCatch2(cb).call(boundTo, e);
                    }
                  } else if (typeof item === "function") {
                    var matchesPredicate = tryCatch2(item).call(boundTo, e);
                    if (matchesPredicate === errorObj2) {
                      return matchesPredicate;
                    } else if (matchesPredicate) {
                      return tryCatch2(cb).call(boundTo, e);
                    }
                  } else if (util.isObject(e)) {
                    var keys = getKeys(item);
                    for (var j = 0; j < keys.length; ++j) {
                      var key = keys[j];
                      if (item[key] != e[key]) {
                        continue predicateLoop;
                      }
                    }
                    return tryCatch2(cb).call(boundTo, e);
                  }
                }
              return NEXT_FILTER;
            };
          }
          return catchFilter;
        };
      }, { "./es5": 13, "./util": 36 }], 8: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var longStackTraces = false;
          var contextStack = [];
          Promise2.prototype._promiseCreated = function() {
          };
          Promise2.prototype._pushContext = function() {
          };
          Promise2.prototype._popContext = function() {
            return null;
          };
          Promise2._peekContext = Promise2.prototype._peekContext = function() {
          };
          function Context() {
            this._trace = new Context.CapturedTrace(peekContext());
          }
          Context.prototype._pushContext = function() {
            if (this._trace !== void 0) {
              this._trace._promiseCreated = null;
              contextStack.push(this._trace);
            }
          };
          Context.prototype._popContext = function() {
            if (this._trace !== void 0) {
              var trace = contextStack.pop();
              var ret2 = trace._promiseCreated;
              trace._promiseCreated = null;
              return ret2;
            }
            return null;
          };
          function createContext() {
            if (longStackTraces)
              return new Context();
          }
          function peekContext() {
            var lastIndex = contextStack.length - 1;
            if (lastIndex >= 0) {
              return contextStack[lastIndex];
            }
            return void 0;
          }
          Context.CapturedTrace = null;
          Context.create = createContext;
          Context.deactivateLongStackTraces = function() {
          };
          Context.activateLongStackTraces = function() {
            var Promise_pushContext = Promise2.prototype._pushContext;
            var Promise_popContext = Promise2.prototype._popContext;
            var Promise_PeekContext = Promise2._peekContext;
            var Promise_peekContext = Promise2.prototype._peekContext;
            var Promise_promiseCreated = Promise2.prototype._promiseCreated;
            Context.deactivateLongStackTraces = function() {
              Promise2.prototype._pushContext = Promise_pushContext;
              Promise2.prototype._popContext = Promise_popContext;
              Promise2._peekContext = Promise_PeekContext;
              Promise2.prototype._peekContext = Promise_peekContext;
              Promise2.prototype._promiseCreated = Promise_promiseCreated;
              longStackTraces = false;
            };
            longStackTraces = true;
            Promise2.prototype._pushContext = Context.prototype._pushContext;
            Promise2.prototype._popContext = Context.prototype._popContext;
            Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
            Promise2.prototype._promiseCreated = function() {
              var ctx = this._peekContext();
              if (ctx && ctx._promiseCreated == null)
                ctx._promiseCreated = this;
            };
          };
          return Context;
        };
      }, {}], 9: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, Context, enableAsyncHooks, disableAsyncHooks) {
          var async = Promise2._async;
          var Warning = _dereq_2("./errors").Warning;
          var util = _dereq_2("./util");
          var es52 = _dereq_2("./es5");
          var canAttachTrace2 = util.canAttachTrace;
          var unhandledRejectionHandled;
          var possiblyUnhandledRejection;
          var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
          var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
          var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
          var stackFramePattern = null;
          var formatStack = null;
          var indentStackFrames = false;
          var printWarning;
          var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && true);
          var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));
          var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
          var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
          var deferUnhandledRejectionCheck;
          (function() {
            var promises = [];
            function unhandledRejectionCheck() {
              for (var i = 0; i < promises.length; ++i) {
                promises[i]._notifyUnhandledRejection();
              }
              unhandledRejectionClear();
            }
            function unhandledRejectionClear() {
              promises.length = 0;
            }
            deferUnhandledRejectionCheck = function(promise) {
              promises.push(promise);
              setTimeout(unhandledRejectionCheck, 1);
            };
            es52.defineProperty(Promise2, "_unhandledRejectionCheck", {
              value: unhandledRejectionCheck
            });
            es52.defineProperty(Promise2, "_unhandledRejectionClear", {
              value: unhandledRejectionClear
            });
          })();
          Promise2.prototype.suppressUnhandledRejections = function() {
            var target = this._target();
            target._bitField = target._bitField & ~1048576 | 524288;
          };
          Promise2.prototype._ensurePossibleRejectionHandled = function() {
            if ((this._bitField & 524288) !== 0)
              return;
            this._setRejectionIsUnhandled();
            deferUnhandledRejectionCheck(this);
          };
          Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
            fireRejectionEvent(
              "rejectionHandled",
              unhandledRejectionHandled,
              void 0,
              this
            );
          };
          Promise2.prototype._setReturnedNonUndefined = function() {
            this._bitField = this._bitField | 268435456;
          };
          Promise2.prototype._returnedNonUndefined = function() {
            return (this._bitField & 268435456) !== 0;
          };
          Promise2.prototype._notifyUnhandledRejection = function() {
            if (this._isRejectionUnhandled()) {
              var reason = this._settledValue();
              this._setUnhandledRejectionIsNotified();
              fireRejectionEvent(
                "unhandledRejection",
                possiblyUnhandledRejection,
                reason,
                this
              );
            }
          };
          Promise2.prototype._setUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField | 262144;
          };
          Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
            this._bitField = this._bitField & ~262144;
          };
          Promise2.prototype._isUnhandledRejectionNotified = function() {
            return (this._bitField & 262144) > 0;
          };
          Promise2.prototype._setRejectionIsUnhandled = function() {
            this._bitField = this._bitField | 1048576;
          };
          Promise2.prototype._unsetRejectionIsUnhandled = function() {
            this._bitField = this._bitField & ~1048576;
            if (this._isUnhandledRejectionNotified()) {
              this._unsetUnhandledRejectionIsNotified();
              this._notifyUnhandledRejectionIsHandled();
            }
          };
          Promise2.prototype._isRejectionUnhandled = function() {
            return (this._bitField & 1048576) > 0;
          };
          Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise) {
            return warn(message, shouldUseOwnTrace, promise || this);
          };
          Promise2.onPossiblyUnhandledRejection = function(fn) {
            var context = Promise2._getContext();
            possiblyUnhandledRejection = util.contextBind(context, fn);
          };
          Promise2.onUnhandledRejectionHandled = function(fn) {
            var context = Promise2._getContext();
            unhandledRejectionHandled = util.contextBind(context, fn);
          };
          var disableLongStackTraces = function() {
          };
          Promise2.longStackTraces = function() {
            if (async.haveItemsQueued() && !config.longStackTraces) {
              throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
            }
            if (!config.longStackTraces && longStackTracesIsSupported()) {
              var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
              var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
              var Promise_dereferenceTrace = Promise2.prototype._dereferenceTrace;
              config.longStackTraces = true;
              disableLongStackTraces = function() {
                if (async.haveItemsQueued() && !config.longStackTraces) {
                  throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
                }
                Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
                Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
                Promise2.prototype._dereferenceTrace = Promise_dereferenceTrace;
                Context.deactivateLongStackTraces();
                config.longStackTraces = false;
              };
              Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
              Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
              Promise2.prototype._dereferenceTrace = longStackTracesDereferenceTrace;
              Context.activateLongStackTraces();
            }
          };
          Promise2.hasLongStackTraces = function() {
            return config.longStackTraces && longStackTracesIsSupported();
          };
          var legacyHandlers = {
            unhandledrejection: {
              before: function() {
                var ret2 = util.global.onunhandledrejection;
                util.global.onunhandledrejection = null;
                return ret2;
              },
              after: function(fn) {
                util.global.onunhandledrejection = fn;
              }
            },
            rejectionhandled: {
              before: function() {
                var ret2 = util.global.onrejectionhandled;
                util.global.onrejectionhandled = null;
                return ret2;
              },
              after: function(fn) {
                util.global.onrejectionhandled = fn;
              }
            }
          };
          var fireDomEvent = function() {
            var dispatch = function(legacy, e) {
              if (legacy) {
                var fn;
                try {
                  fn = legacy.before();
                  return !util.global.dispatchEvent(e);
                } finally {
                  legacy.after(fn);
                }
              } else {
                return !util.global.dispatchEvent(e);
              }
            };
            try {
              if (typeof CustomEvent === "function") {
                var event = new CustomEvent("CustomEvent");
                util.global.dispatchEvent(event);
                return function(name, event2) {
                  name = name.toLowerCase();
                  var eventData = {
                    detail: event2,
                    cancelable: true
                  };
                  var domEvent = new CustomEvent(name, eventData);
                  es52.defineProperty(
                    domEvent,
                    "promise",
                    { value: event2.promise }
                  );
                  es52.defineProperty(
                    domEvent,
                    "reason",
                    { value: event2.reason }
                  );
                  return dispatch(legacyHandlers[name], domEvent);
                };
              } else if (typeof Event === "function") {
                var event = new Event("CustomEvent");
                util.global.dispatchEvent(event);
                return function(name, event2) {
                  name = name.toLowerCase();
                  var domEvent = new Event(name, {
                    cancelable: true
                  });
                  domEvent.detail = event2;
                  es52.defineProperty(domEvent, "promise", { value: event2.promise });
                  es52.defineProperty(domEvent, "reason", { value: event2.reason });
                  return dispatch(legacyHandlers[name], domEvent);
                };
              } else {
                var event = document.createEvent("CustomEvent");
                event.initCustomEvent("testingtheevent", false, true, {});
                util.global.dispatchEvent(event);
                return function(name, event2) {
                  name = name.toLowerCase();
                  var domEvent = document.createEvent("CustomEvent");
                  domEvent.initCustomEvent(
                    name,
                    false,
                    true,
                    event2
                  );
                  return dispatch(legacyHandlers[name], domEvent);
                };
              }
            } catch (e) {
            }
            return function() {
              return false;
            };
          }();
          var fireGlobalEvent = function() {
            if (util.isNode) {
              return function() {
                return process.emit.apply(process, arguments);
              };
            } else {
              if (!util.global) {
                return function() {
                  return false;
                };
              }
              return function(name) {
                var methodName = "on" + name.toLowerCase();
                var method = util.global[methodName];
                if (!method)
                  return false;
                method.apply(util.global, [].slice.call(arguments, 1));
                return true;
              };
            }
          }();
          function generatePromiseLifecycleEventObject(name, promise) {
            return { promise };
          }
          var eventToObjectGenerator = {
            promiseCreated: generatePromiseLifecycleEventObject,
            promiseFulfilled: generatePromiseLifecycleEventObject,
            promiseRejected: generatePromiseLifecycleEventObject,
            promiseResolved: generatePromiseLifecycleEventObject,
            promiseCancelled: generatePromiseLifecycleEventObject,
            promiseChained: function(name, promise, child) {
              return { promise, child };
            },
            warning: function(name, warning) {
              return { warning };
            },
            unhandledRejection: function(name, reason, promise) {
              return { reason, promise };
            },
            rejectionHandled: generatePromiseLifecycleEventObject
          };
          var activeFireEvent = function(name) {
            var globalEventFired = false;
            try {
              globalEventFired = fireGlobalEvent.apply(null, arguments);
            } catch (e) {
              async.throwLater(e);
              globalEventFired = true;
            }
            var domEventFired = false;
            try {
              domEventFired = fireDomEvent(
                name,
                eventToObjectGenerator[name].apply(null, arguments)
              );
            } catch (e) {
              async.throwLater(e);
              domEventFired = true;
            }
            return domEventFired || globalEventFired;
          };
          Promise2.config = function(opts) {
            opts = Object(opts);
            if ("longStackTraces" in opts) {
              if (opts.longStackTraces) {
                Promise2.longStackTraces();
              } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
                disableLongStackTraces();
              }
            }
            if ("warnings" in opts) {
              var warningsOption = opts.warnings;
              config.warnings = !!warningsOption;
              wForgottenReturn = config.warnings;
              if (util.isObject(warningsOption)) {
                if ("wForgottenReturn" in warningsOption) {
                  wForgottenReturn = !!warningsOption.wForgottenReturn;
                }
              }
            }
            if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
              if (async.haveItemsQueued()) {
                throw new Error(
                  "cannot enable cancellation after promises are in use"
                );
              }
              Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
              Promise2.prototype._propagateFrom = cancellationPropagateFrom;
              Promise2.prototype._onCancel = cancellationOnCancel;
              Promise2.prototype._setOnCancel = cancellationSetOnCancel;
              Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
              Promise2.prototype._execute = cancellationExecute;
              propagateFromFunction = cancellationPropagateFrom;
              config.cancellation = true;
            }
            if ("monitoring" in opts) {
              if (opts.monitoring && !config.monitoring) {
                config.monitoring = true;
                Promise2.prototype._fireEvent = activeFireEvent;
              } else if (!opts.monitoring && config.monitoring) {
                config.monitoring = false;
                Promise2.prototype._fireEvent = defaultFireEvent;
              }
            }
            if ("asyncHooks" in opts && util.nodeSupportsAsyncResource) {
              var prev = config.asyncHooks;
              var cur = !!opts.asyncHooks;
              if (prev !== cur) {
                config.asyncHooks = cur;
                if (cur) {
                  enableAsyncHooks();
                } else {
                  disableAsyncHooks();
                }
              }
            }
            return Promise2;
          };
          function defaultFireEvent() {
            return false;
          }
          Promise2.prototype._fireEvent = defaultFireEvent;
          Promise2.prototype._execute = function(executor, resolve, reject) {
            try {
              executor(resolve, reject);
            } catch (e) {
              return e;
            }
          };
          Promise2.prototype._onCancel = function() {
          };
          Promise2.prototype._setOnCancel = function(handler) {
            ;
          };
          Promise2.prototype._attachCancellationCallback = function(onCancel) {
            ;
          };
          Promise2.prototype._captureStackTrace = function() {
          };
          Promise2.prototype._attachExtraTrace = function() {
          };
          Promise2.prototype._dereferenceTrace = function() {
          };
          Promise2.prototype._clearCancellationData = function() {
          };
          Promise2.prototype._propagateFrom = function(parent, flags) {
            ;
            ;
          };
          function cancellationExecute(executor, resolve, reject) {
            var promise = this;
            try {
              executor(resolve, reject, function(onCancel) {
                if (typeof onCancel !== "function") {
                  throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
                }
                promise._attachCancellationCallback(onCancel);
              });
            } catch (e) {
              return e;
            }
          }
          function cancellationAttachCancellationCallback(onCancel) {
            if (!this._isCancellable())
              return this;
            var previousOnCancel = this._onCancel();
            if (previousOnCancel !== void 0) {
              if (util.isArray(previousOnCancel)) {
                previousOnCancel.push(onCancel);
              } else {
                this._setOnCancel([previousOnCancel, onCancel]);
              }
            } else {
              this._setOnCancel(onCancel);
            }
          }
          function cancellationOnCancel() {
            return this._onCancelField;
          }
          function cancellationSetOnCancel(onCancel) {
            this._onCancelField = onCancel;
          }
          function cancellationClearCancellationData() {
            this._cancellationParent = void 0;
            this._onCancelField = void 0;
          }
          function cancellationPropagateFrom(parent, flags) {
            if ((flags & 1) !== 0) {
              this._cancellationParent = parent;
              var branchesRemainingToCancel = parent._branchesRemainingToCancel;
              if (branchesRemainingToCancel === void 0) {
                branchesRemainingToCancel = 0;
              }
              parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
            }
            if ((flags & 2) !== 0 && parent._isBound()) {
              this._setBoundTo(parent._boundTo);
            }
          }
          function bindingPropagateFrom(parent, flags) {
            if ((flags & 2) !== 0 && parent._isBound()) {
              this._setBoundTo(parent._boundTo);
            }
          }
          var propagateFromFunction = bindingPropagateFrom;
          function boundValueFunction() {
            var ret2 = this._boundTo;
            if (ret2 !== void 0) {
              if (ret2 instanceof Promise2) {
                if (ret2.isFulfilled()) {
                  return ret2.value();
                } else {
                  return void 0;
                }
              }
            }
            return ret2;
          }
          function longStackTracesCaptureStackTrace() {
            this._trace = new CapturedTrace(this._peekContext());
          }
          function longStackTracesAttachExtraTrace(error, ignoreSelf) {
            if (canAttachTrace2(error)) {
              var trace = this._trace;
              if (trace !== void 0) {
                if (ignoreSelf)
                  trace = trace._parent;
              }
              if (trace !== void 0) {
                trace.attachExtraTrace(error);
              } else if (!error.__stackCleaned__) {
                var parsed = parseStackAndMessage(error);
                util.notEnumerableProp(
                  error,
                  "stack",
                  parsed.message + "\n" + parsed.stack.join("\n")
                );
                util.notEnumerableProp(error, "__stackCleaned__", true);
              }
            }
          }
          function longStackTracesDereferenceTrace() {
            this._trace = void 0;
          }
          function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
            if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
              if (parent !== void 0 && parent._returnedNonUndefined())
                return;
              if ((promise._bitField & 65535) === 0)
                return;
              if (name)
                name = name + " ";
              var handlerLine = "";
              var creatorLine = "";
              if (promiseCreated._trace) {
                var traceLines = promiseCreated._trace.stack.split("\n");
                var stack = cleanStack(traceLines);
                for (var i = stack.length - 1; i >= 0; --i) {
                  var line = stack[i];
                  if (!nodeFramePattern.test(line)) {
                    var lineMatches = line.match(parseLinePattern);
                    if (lineMatches) {
                      handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                    }
                    break;
                  }
                }
                if (stack.length > 0) {
                  var firstUserLine = stack[0];
                  for (var i = 0; i < traceLines.length; ++i) {
                    if (traceLines[i] === firstUserLine) {
                      if (i > 0) {
                        creatorLine = "\n" + traceLines[i - 1];
                      }
                      break;
                    }
                  }
                }
              }
              var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
              promise._warn(msg, true, promiseCreated);
            }
          }
          function deprecated(name, replacement) {
            var message = name + " is deprecated and will be removed in a future version.";
            if (replacement)
              message += " Use " + replacement + " instead.";
            return warn(message);
          }
          function warn(message, shouldUseOwnTrace, promise) {
            if (!config.warnings)
              return;
            var warning = new Warning(message);
            var ctx;
            if (shouldUseOwnTrace) {
              promise._attachExtraTrace(warning);
            } else if (config.longStackTraces && (ctx = Promise2._peekContext())) {
              ctx.attachExtraTrace(warning);
            } else {
              var parsed = parseStackAndMessage(warning);
              warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
            }
            if (!activeFireEvent("warning", warning)) {
              formatAndLogError(warning, "", true);
            }
          }
          function reconstructStack(message, stacks) {
            for (var i = 0; i < stacks.length - 1; ++i) {
              stacks[i].push("From previous event:");
              stacks[i] = stacks[i].join("\n");
            }
            if (i < stacks.length) {
              stacks[i] = stacks[i].join("\n");
            }
            return message + "\n" + stacks.join("\n");
          }
          function removeDuplicateOrEmptyJumps(stacks) {
            for (var i = 0; i < stacks.length; ++i) {
              if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
                stacks.splice(i, 1);
                i--;
              }
            }
          }
          function removeCommonRoots(stacks) {
            var current = stacks[0];
            for (var i = 1; i < stacks.length; ++i) {
              var prev = stacks[i];
              var currentLastIndex = current.length - 1;
              var currentLastLine = current[currentLastIndex];
              var commonRootMeetPoint = -1;
              for (var j = prev.length - 1; j >= 0; --j) {
                if (prev[j] === currentLastLine) {
                  commonRootMeetPoint = j;
                  break;
                }
              }
              for (var j = commonRootMeetPoint; j >= 0; --j) {
                var line = prev[j];
                if (current[currentLastIndex] === line) {
                  current.pop();
                  currentLastIndex--;
                } else {
                  break;
                }
              }
              current = prev;
            }
          }
          function cleanStack(stack) {
            var ret2 = [];
            for (var i = 0; i < stack.length; ++i) {
              var line = stack[i];
              var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
              var isInternalFrame = isTraceLine && shouldIgnore(line);
              if (isTraceLine && !isInternalFrame) {
                if (indentStackFrames && line.charAt(0) !== " ") {
                  line = "    " + line;
                }
                ret2.push(line);
              }
            }
            return ret2;
          }
          function stackFramesAsArray(error) {
            var stack = error.stack.replace(/\s+$/g, "").split("\n");
            for (var i = 0; i < stack.length; ++i) {
              var line = stack[i];
              if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                break;
              }
            }
            if (i > 0 && error.name != "SyntaxError") {
              stack = stack.slice(i);
            }
            return stack;
          }
          function parseStackAndMessage(error) {
            var stack = error.stack;
            var message = error.toString();
            stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
            return {
              message,
              stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
            };
          }
          function formatAndLogError(error, title, isSoft) {
            if (typeof console !== "undefined") {
              var message;
              if (util.isObject(error)) {
                var stack = error.stack;
                message = title + formatStack(stack, error);
              } else {
                message = title + String(error);
              }
              if (typeof printWarning === "function") {
                printWarning(message, isSoft);
              } else if (typeof console.log === "function" || typeof console.log === "object") {
                console.log(message);
              }
            }
          }
          function fireRejectionEvent(name, localHandler, reason, promise) {
            var localEventFired = false;
            try {
              if (typeof localHandler === "function") {
                localEventFired = true;
                if (name === "rejectionHandled") {
                  localHandler(promise);
                } else {
                  localHandler(reason, promise);
                }
              }
            } catch (e) {
              async.throwLater(e);
            }
            if (name === "unhandledRejection") {
              if (!activeFireEvent(name, reason, promise) && !localEventFired) {
                formatAndLogError(reason, "Unhandled rejection ");
              }
            } else {
              activeFireEvent(name, promise);
            }
          }
          function formatNonError(obj2) {
            var str;
            if (typeof obj2 === "function") {
              str = "[function " + (obj2.name || "anonymous") + "]";
            } else {
              str = obj2 && typeof obj2.toString === "function" ? obj2.toString() : util.toString(obj2);
              var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
              if (ruselessToString.test(str)) {
                try {
                  var newStr = JSON.stringify(obj2);
                  str = newStr;
                } catch (e) {
                }
              }
              if (str.length === 0) {
                str = "(empty array)";
              }
            }
            return "(<" + snip(str) + ">, no stack trace)";
          }
          function snip(str) {
            var maxChars = 41;
            if (str.length < maxChars) {
              return str;
            }
            return str.substr(0, maxChars - 3) + "...";
          }
          function longStackTracesIsSupported() {
            return typeof captureStackTrace === "function";
          }
          var shouldIgnore = function() {
            return false;
          };
          var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
          function parseLineInfo(line) {
            var matches = line.match(parseLineInfoRegex);
            if (matches) {
              return {
                fileName: matches[1],
                line: parseInt(matches[2], 10)
              };
            }
          }
          function setBounds(firstLineError, lastLineError) {
            if (!longStackTracesIsSupported())
              return;
            var firstStackLines = (firstLineError.stack || "").split("\n");
            var lastStackLines = (lastLineError.stack || "").split("\n");
            var firstIndex = -1;
            var lastIndex = -1;
            var firstFileName;
            var lastFileName;
            for (var i = 0; i < firstStackLines.length; ++i) {
              var result = parseLineInfo(firstStackLines[i]);
              if (result) {
                firstFileName = result.fileName;
                firstIndex = result.line;
                break;
              }
            }
            for (var i = 0; i < lastStackLines.length; ++i) {
              var result = parseLineInfo(lastStackLines[i]);
              if (result) {
                lastFileName = result.fileName;
                lastIndex = result.line;
                break;
              }
            }
            if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
              return;
            }
            shouldIgnore = function(line) {
              if (bluebirdFramePattern.test(line))
                return true;
              var info = parseLineInfo(line);
              if (info) {
                if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
                  return true;
                }
              }
              return false;
            };
          }
          function CapturedTrace(parent) {
            this._parent = parent;
            this._promisesCreated = 0;
            var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
            captureStackTrace(this, CapturedTrace);
            if (length > 32)
              this.uncycle();
          }
          util.inherits(CapturedTrace, Error);
          Context.CapturedTrace = CapturedTrace;
          CapturedTrace.prototype.uncycle = function() {
            var length = this._length;
            if (length < 2)
              return;
            var nodes = [];
            var stackToIndex = {};
            for (var i = 0, node = this; node !== void 0; ++i) {
              nodes.push(node);
              node = node._parent;
            }
            length = this._length = i;
            for (var i = length - 1; i >= 0; --i) {
              var stack = nodes[i].stack;
              if (stackToIndex[stack] === void 0) {
                stackToIndex[stack] = i;
              }
            }
            for (var i = 0; i < length; ++i) {
              var currentStack = nodes[i].stack;
              var index = stackToIndex[currentStack];
              if (index !== void 0 && index !== i) {
                if (index > 0) {
                  nodes[index - 1]._parent = void 0;
                  nodes[index - 1]._length = 1;
                }
                nodes[i]._parent = void 0;
                nodes[i]._length = 1;
                var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
                if (index < length - 1) {
                  cycleEdgeNode._parent = nodes[index + 1];
                  cycleEdgeNode._parent.uncycle();
                  cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
                } else {
                  cycleEdgeNode._parent = void 0;
                  cycleEdgeNode._length = 1;
                }
                var currentChildLength = cycleEdgeNode._length + 1;
                for (var j = i - 2; j >= 0; --j) {
                  nodes[j]._length = currentChildLength;
                  currentChildLength++;
                }
                return;
              }
            }
          };
          CapturedTrace.prototype.attachExtraTrace = function(error) {
            if (error.__stackCleaned__)
              return;
            this.uncycle();
            var parsed = parseStackAndMessage(error);
            var message = parsed.message;
            var stacks = [parsed.stack];
            var trace = this;
            while (trace !== void 0) {
              stacks.push(cleanStack(trace.stack.split("\n")));
              trace = trace._parent;
            }
            removeCommonRoots(stacks);
            removeDuplicateOrEmptyJumps(stacks);
            util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
            util.notEnumerableProp(error, "__stackCleaned__", true);
          };
          var captureStackTrace = function stackDetection() {
            var v8stackFramePattern = /^\s*at\s*/;
            var v8stackFormatter = function(stack, error) {
              if (typeof stack === "string")
                return stack;
              if (error.name !== void 0 && error.message !== void 0) {
                return error.toString();
              }
              return formatNonError(error);
            };
            if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
              Error.stackTraceLimit += 6;
              stackFramePattern = v8stackFramePattern;
              formatStack = v8stackFormatter;
              var captureStackTrace2 = Error.captureStackTrace;
              shouldIgnore = function(line) {
                return bluebirdFramePattern.test(line);
              };
              return function(receiver2, ignoreUntil) {
                Error.stackTraceLimit += 6;
                captureStackTrace2(receiver2, ignoreUntil);
                Error.stackTraceLimit -= 6;
              };
            }
            var err = new Error();
            if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
              stackFramePattern = /@/;
              formatStack = v8stackFormatter;
              indentStackFrames = true;
              return function captureStackTrace3(o) {
                o.stack = new Error().stack;
              };
            }
            var hasStackAfterThrow;
            try {
              throw new Error();
            } catch (e) {
              hasStackAfterThrow = "stack" in e;
            }
            if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
              stackFramePattern = v8stackFramePattern;
              formatStack = v8stackFormatter;
              return function captureStackTrace3(o) {
                Error.stackTraceLimit += 6;
                try {
                  throw new Error();
                } catch (e) {
                  o.stack = e.stack;
                }
                Error.stackTraceLimit -= 6;
              };
            }
            formatStack = function(stack, error) {
              if (typeof stack === "string")
                return stack;
              if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
                return error.toString();
              }
              return formatNonError(error);
            };
            return null;
          }([]);
          if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
            printWarning = function(message) {
              console.warn(message);
            };
            if (util.isNode && process.stderr.isTTY) {
              printWarning = function(message, isSoft) {
                var color = isSoft ? "\x1B[33m" : "\x1B[31m";
                console.warn(color + message + "\x1B[0m\n");
              };
            } else if (!util.isNode && typeof new Error().stack === "string") {
              printWarning = function(message, isSoft) {
                console.warn(
                  "%c" + message,
                  isSoft ? "color: darkorange" : "color: red"
                );
              };
            }
          }
          var config = {
            warnings,
            longStackTraces: false,
            cancellation: false,
            monitoring: false,
            asyncHooks: false
          };
          if (longStackTraces)
            Promise2.longStackTraces();
          return {
            asyncHooks: function() {
              return config.asyncHooks;
            },
            longStackTraces: function() {
              return config.longStackTraces;
            },
            warnings: function() {
              return config.warnings;
            },
            cancellation: function() {
              return config.cancellation;
            },
            monitoring: function() {
              return config.monitoring;
            },
            propagateFromFunction: function() {
              return propagateFromFunction;
            },
            boundValueFunction: function() {
              return boundValueFunction;
            },
            checkForgottenReturns,
            setBounds,
            warn,
            deprecated,
            CapturedTrace,
            fireDomEvent,
            fireGlobalEvent
          };
        };
      }, { "./errors": 12, "./es5": 13, "./util": 36 }], 10: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          function returner() {
            return this.value;
          }
          function thrower2() {
            throw this.reason;
          }
          Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
            if (value instanceof Promise2)
              value.suppressUnhandledRejections();
            return this._then(
              returner,
              void 0,
              void 0,
              { value },
              void 0
            );
          };
          Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
            return this._then(
              thrower2,
              void 0,
              void 0,
              { reason },
              void 0
            );
          };
          Promise2.prototype.catchThrow = function(reason) {
            if (arguments.length <= 1) {
              return this._then(
                void 0,
                thrower2,
                void 0,
                { reason },
                void 0
              );
            } else {
              var _reason = arguments[1];
              var handler = function() {
                throw _reason;
              };
              return this.caught(reason, handler);
            }
          };
          Promise2.prototype.catchReturn = function(value) {
            if (arguments.length <= 1) {
              if (value instanceof Promise2)
                value.suppressUnhandledRejections();
              return this._then(
                void 0,
                returner,
                void 0,
                { value },
                void 0
              );
            } else {
              var _value = arguments[1];
              if (_value instanceof Promise2)
                _value.suppressUnhandledRejections();
              var handler = function() {
                return _value;
              };
              return this.caught(value, handler);
            }
          };
        };
      }, {}], 11: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var PromiseReduce = Promise2.reduce;
          var PromiseAll = Promise2.all;
          function promiseAllThis() {
            return PromiseAll(this);
          }
          function PromiseMapSeries(promises, fn) {
            return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
          }
          Promise2.prototype.each = function(fn) {
            return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
          };
          Promise2.prototype.mapSeries = function(fn) {
            return PromiseReduce(this, fn, INTERNAL, INTERNAL);
          };
          Promise2.each = function(promises, fn) {
            return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
          };
          Promise2.mapSeries = PromiseMapSeries;
        };
      }, {}], 12: [function(_dereq_2, module2, exports2) {
        "use strict";
        var es52 = _dereq_2("./es5");
        var Objectfreeze = es52.freeze;
        var util = _dereq_2("./util");
        var inherits2 = util.inherits;
        var notEnumerableProp2 = util.notEnumerableProp;
        function subError(nameProperty, defaultMessage) {
          function SubError(message) {
            if (!(this instanceof SubError))
              return new SubError(message);
            notEnumerableProp2(
              this,
              "message",
              typeof message === "string" ? message : defaultMessage
            );
            notEnumerableProp2(this, "name", nameProperty);
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            } else {
              Error.call(this);
            }
          }
          inherits2(SubError, Error);
          return SubError;
        }
        var _TypeError, _RangeError;
        var Warning = subError("Warning", "warning");
        var CancellationError = subError("CancellationError", "cancellation error");
        var TimeoutError = subError("TimeoutError", "timeout error");
        var AggregateError = subError("AggregateError", "aggregate error");
        try {
          _TypeError = TypeError;
          _RangeError = RangeError;
        } catch (e) {
          _TypeError = subError("TypeError", "type error");
          _RangeError = subError("RangeError", "range error");
        }
        var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
        for (var i = 0; i < methods.length; ++i) {
          if (typeof Array.prototype[methods[i]] === "function") {
            AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
          }
        }
        es52.defineProperty(AggregateError.prototype, "length", {
          value: 0,
          configurable: false,
          writable: true,
          enumerable: true
        });
        AggregateError.prototype["isOperational"] = true;
        var level = 0;
        AggregateError.prototype.toString = function() {
          var indent = Array(level * 4 + 1).join(" ");
          var ret2 = "\n" + indent + "AggregateError of:\n";
          level++;
          indent = Array(level * 4 + 1).join(" ");
          for (var i2 = 0; i2 < this.length; ++i2) {
            var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
            var lines = str.split("\n");
            for (var j = 0; j < lines.length; ++j) {
              lines[j] = indent + lines[j];
            }
            str = lines.join("\n");
            ret2 += str + "\n";
          }
          level--;
          return ret2;
        };
        function OperationalError(message) {
          if (!(this instanceof OperationalError))
            return new OperationalError(message);
          notEnumerableProp2(this, "name", "OperationalError");
          notEnumerableProp2(this, "message", message);
          this.cause = message;
          this["isOperational"] = true;
          if (message instanceof Error) {
            notEnumerableProp2(this, "message", message.message);
            notEnumerableProp2(this, "stack", message.stack);
          } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        }
        inherits2(OperationalError, Error);
        var errorTypes = Error["__BluebirdErrorTypes__"];
        if (!errorTypes) {
          errorTypes = Objectfreeze({
            CancellationError,
            TimeoutError,
            OperationalError,
            RejectionError: OperationalError,
            AggregateError
          });
          es52.defineProperty(Error, "__BluebirdErrorTypes__", {
            value: errorTypes,
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
        module2.exports = {
          Error,
          TypeError: _TypeError,
          RangeError: _RangeError,
          CancellationError: errorTypes.CancellationError,
          OperationalError: errorTypes.OperationalError,
          TimeoutError: errorTypes.TimeoutError,
          AggregateError: errorTypes.AggregateError,
          Warning
        };
      }, { "./es5": 13, "./util": 36 }], 13: [function(_dereq_2, module2, exports2) {
        var isES5 = function() {
          "use strict";
          return this === void 0;
        }();
        if (isES5) {
          module2.exports = {
            freeze: Object.freeze,
            defineProperty: Object.defineProperty,
            getDescriptor: Object.getOwnPropertyDescriptor,
            keys: Object.keys,
            names: Object.getOwnPropertyNames,
            getPrototypeOf: Object.getPrototypeOf,
            isArray: Array.isArray,
            isES5,
            propertyIsWritable: function(obj2, prop) {
              var descriptor = Object.getOwnPropertyDescriptor(obj2, prop);
              return !!(!descriptor || descriptor.writable || descriptor.set);
            }
          };
        } else {
          var has = {}.hasOwnProperty;
          var str = {}.toString;
          var proto = {}.constructor.prototype;
          var ObjectKeys = function(o) {
            var ret2 = [];
            for (var key in o) {
              if (has.call(o, key)) {
                ret2.push(key);
              }
            }
            return ret2;
          };
          var ObjectGetDescriptor = function(o, key) {
            return { value: o[key] };
          };
          var ObjectDefineProperty = function(o, key, desc) {
            o[key] = desc.value;
            return o;
          };
          var ObjectFreeze = function(obj2) {
            return obj2;
          };
          var ObjectGetPrototypeOf = function(obj2) {
            try {
              return Object(obj2).constructor.prototype;
            } catch (e) {
              return proto;
            }
          };
          var ArrayIsArray = function(obj2) {
            try {
              return str.call(obj2) === "[object Array]";
            } catch (e) {
              return false;
            }
          };
          module2.exports = {
            isArray: ArrayIsArray,
            keys: ObjectKeys,
            names: ObjectKeys,
            defineProperty: ObjectDefineProperty,
            getDescriptor: ObjectGetDescriptor,
            freeze: ObjectFreeze,
            getPrototypeOf: ObjectGetPrototypeOf,
            isES5,
            propertyIsWritable: function() {
              return true;
            }
          };
        }
      }, {}], 14: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var PromiseMap = Promise2.map;
          Promise2.prototype.filter = function(fn, options) {
            return PromiseMap(this, fn, options, INTERNAL);
          };
          Promise2.filter = function(promises, fn, options) {
            return PromiseMap(promises, fn, options, INTERNAL);
          };
        };
      }, {}], 15: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, tryConvertToPromise, NEXT_FILTER) {
          var util = _dereq_2("./util");
          var CancellationError = Promise2.CancellationError;
          var errorObj2 = util.errorObj;
          var catchFilter = _dereq_2("./catch_filter")(NEXT_FILTER);
          function PassThroughHandlerContext(promise, type, handler) {
            this.promise = promise;
            this.type = type;
            this.handler = handler;
            this.called = false;
            this.cancelPromise = null;
          }
          PassThroughHandlerContext.prototype.isFinallyHandler = function() {
            return this.type === 0;
          };
          function FinallyHandlerCancelReaction(finallyHandler2) {
            this.finallyHandler = finallyHandler2;
          }
          FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
            checkCancel(this.finallyHandler);
          };
          function checkCancel(ctx, reason) {
            if (ctx.cancelPromise != null) {
              if (arguments.length > 1) {
                ctx.cancelPromise._reject(reason);
              } else {
                ctx.cancelPromise._cancel();
              }
              ctx.cancelPromise = null;
              return true;
            }
            return false;
          }
          function succeed() {
            return finallyHandler.call(this, this.promise._target()._settledValue());
          }
          function fail(reason) {
            if (checkCancel(this, reason))
              return;
            errorObj2.e = reason;
            return errorObj2;
          }
          function finallyHandler(reasonOrValue) {
            var promise = this.promise;
            var handler = this.handler;
            if (!this.called) {
              this.called = true;
              var ret2 = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
              if (ret2 === NEXT_FILTER) {
                return ret2;
              } else if (ret2 !== void 0) {
                promise._setReturnedNonUndefined();
                var maybePromise = tryConvertToPromise(ret2, promise);
                if (maybePromise instanceof Promise2) {
                  if (this.cancelPromise != null) {
                    if (maybePromise._isCancelled()) {
                      var reason = new CancellationError("late cancellation observer");
                      promise._attachExtraTrace(reason);
                      errorObj2.e = reason;
                      return errorObj2;
                    } else if (maybePromise.isPending()) {
                      maybePromise._attachCancellationCallback(
                        new FinallyHandlerCancelReaction(this)
                      );
                    }
                  }
                  return maybePromise._then(
                    succeed,
                    fail,
                    void 0,
                    this,
                    void 0
                  );
                }
              }
            }
            if (promise.isRejected()) {
              checkCancel(this);
              errorObj2.e = reasonOrValue;
              return errorObj2;
            } else {
              checkCancel(this);
              return reasonOrValue;
            }
          }
          Promise2.prototype._passThrough = function(handler, type, success, fail2) {
            if (typeof handler !== "function")
              return this.then();
            return this._then(
              success,
              fail2,
              void 0,
              new PassThroughHandlerContext(this, type, handler),
              void 0
            );
          };
          Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
            return this._passThrough(
              handler,
              0,
              finallyHandler,
              finallyHandler
            );
          };
          Promise2.prototype.tap = function(handler) {
            return this._passThrough(handler, 1, finallyHandler);
          };
          Promise2.prototype.tapCatch = function(handlerOrPredicate) {
            var len = arguments.length;
            if (len === 1) {
              return this._passThrough(
                handlerOrPredicate,
                1,
                void 0,
                finallyHandler
              );
            } else {
              var catchInstances = new Array(len - 1), j = 0, i;
              for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (util.isObject(item)) {
                  catchInstances[j++] = item;
                } else {
                  return Promise2.reject(new TypeError(
                    "tapCatch statement predicate: expecting an object but got " + util.classString(item)
                  ));
                }
              }
              catchInstances.length = j;
              var handler = arguments[i];
              return this._passThrough(
                catchFilter(catchInstances, handler, this),
                1,
                void 0,
                finallyHandler
              );
            }
          };
          return PassThroughHandlerContext;
        };
      }, { "./catch_filter": 7, "./util": 36 }], 16: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
          var errors = _dereq_2("./errors");
          var TypeError2 = errors.TypeError;
          var util = _dereq_2("./util");
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          var yieldHandlers = [];
          function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
            for (var i = 0; i < yieldHandlers2.length; ++i) {
              traceParent._pushContext();
              var result = tryCatch2(yieldHandlers2[i])(value);
              traceParent._popContext();
              if (result === errorObj2) {
                traceParent._pushContext();
                var ret2 = Promise2.reject(errorObj2.e);
                traceParent._popContext();
                return ret2;
              }
              var maybePromise = tryConvertToPromise(result, traceParent);
              if (maybePromise instanceof Promise2)
                return maybePromise;
            }
            return null;
          }
          function PromiseSpawn(generatorFunction, receiver2, yieldHandler, stack) {
            if (debug.cancellation()) {
              var internal = new Promise2(INTERNAL);
              var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
              this._promise = internal.lastly(function() {
                return _finallyPromise;
              });
              internal._captureStackTrace();
              internal._setOnCancel(this);
            } else {
              var promise = this._promise = new Promise2(INTERNAL);
              promise._captureStackTrace();
            }
            this._stack = stack;
            this._generatorFunction = generatorFunction;
            this._receiver = receiver2;
            this._generator = void 0;
            this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
            this._yieldedPromise = null;
            this._cancellationPhase = false;
          }
          util.inherits(PromiseSpawn, Proxyable);
          PromiseSpawn.prototype._isResolved = function() {
            return this._promise === null;
          };
          PromiseSpawn.prototype._cleanup = function() {
            this._promise = this._generator = null;
            if (debug.cancellation() && this._finallyPromise !== null) {
              this._finallyPromise._fulfill();
              this._finallyPromise = null;
            }
          };
          PromiseSpawn.prototype._promiseCancelled = function() {
            if (this._isResolved())
              return;
            var implementsReturn = typeof this._generator["return"] !== "undefined";
            var result;
            if (!implementsReturn) {
              var reason = new Promise2.CancellationError(
                "generator .return() sentinel"
              );
              Promise2.coroutine.returnSentinel = reason;
              this._promise._attachExtraTrace(reason);
              this._promise._pushContext();
              result = tryCatch2(this._generator["throw"]).call(
                this._generator,
                reason
              );
              this._promise._popContext();
            } else {
              this._promise._pushContext();
              result = tryCatch2(this._generator["return"]).call(
                this._generator,
                void 0
              );
              this._promise._popContext();
            }
            this._cancellationPhase = true;
            this._yieldedPromise = null;
            this._continue(result);
          };
          PromiseSpawn.prototype._promiseFulfilled = function(value) {
            this._yieldedPromise = null;
            this._promise._pushContext();
            var result = tryCatch2(this._generator.next).call(this._generator, value);
            this._promise._popContext();
            this._continue(result);
          };
          PromiseSpawn.prototype._promiseRejected = function(reason) {
            this._yieldedPromise = null;
            this._promise._attachExtraTrace(reason);
            this._promise._pushContext();
            var result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
            this._promise._popContext();
            this._continue(result);
          };
          PromiseSpawn.prototype._resultCancelled = function() {
            if (this._yieldedPromise instanceof Promise2) {
              var promise = this._yieldedPromise;
              this._yieldedPromise = null;
              promise.cancel();
            }
          };
          PromiseSpawn.prototype.promise = function() {
            return this._promise;
          };
          PromiseSpawn.prototype._run = function() {
            this._generator = this._generatorFunction.call(this._receiver);
            this._receiver = this._generatorFunction = void 0;
            this._promiseFulfilled(void 0);
          };
          PromiseSpawn.prototype._continue = function(result) {
            var promise = this._promise;
            if (result === errorObj2) {
              this._cleanup();
              if (this._cancellationPhase) {
                return promise.cancel();
              } else {
                return promise._rejectCallback(result.e, false);
              }
            }
            var value = result.value;
            if (result.done === true) {
              this._cleanup();
              if (this._cancellationPhase) {
                return promise.cancel();
              } else {
                return promise._resolveCallback(value);
              }
            } else {
              var maybePromise = tryConvertToPromise(value, this._promise);
              if (!(maybePromise instanceof Promise2)) {
                maybePromise = promiseFromYieldHandler(
                  maybePromise,
                  this._yieldHandlers,
                  this._promise
                );
                if (maybePromise === null) {
                  this._promiseRejected(
                    new TypeError2(
                      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(value)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
                    )
                  );
                  return;
                }
              }
              maybePromise = maybePromise._target();
              var bitField = maybePromise._bitField;
              ;
              if ((bitField & 50397184) === 0) {
                this._yieldedPromise = maybePromise;
                maybePromise._proxy(this, null);
              } else if ((bitField & 33554432) !== 0) {
                Promise2._async.invoke(
                  this._promiseFulfilled,
                  this,
                  maybePromise._value()
                );
              } else if ((bitField & 16777216) !== 0) {
                Promise2._async.invoke(
                  this._promiseRejected,
                  this,
                  maybePromise._reason()
                );
              } else {
                this._promiseCancelled();
              }
            }
          };
          Promise2.coroutine = function(generatorFunction, options) {
            if (typeof generatorFunction !== "function") {
              throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
            }
            var yieldHandler = Object(options).yieldHandler;
            var PromiseSpawn$ = PromiseSpawn;
            var stack = new Error().stack;
            return function() {
              var generator = generatorFunction.apply(this, arguments);
              var spawn = new PromiseSpawn$(
                void 0,
                void 0,
                yieldHandler,
                stack
              );
              var ret2 = spawn.promise();
              spawn._generator = generator;
              spawn._promiseFulfilled(void 0);
              return ret2;
            };
          };
          Promise2.coroutine.addYieldHandler = function(fn) {
            if (typeof fn !== "function") {
              throw new TypeError2("expecting a function but got " + util.classString(fn));
            }
            yieldHandlers.push(fn);
          };
          Promise2.spawn = function(generatorFunction) {
            debug.deprecated("Promise.spawn()", "Promise.coroutine()");
            if (typeof generatorFunction !== "function") {
              return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
            }
            var spawn = new PromiseSpawn(generatorFunction, this);
            var ret2 = spawn.promise();
            spawn._run(Promise2.spawn);
            return ret2;
          };
        };
      }, { "./errors": 12, "./util": 36 }], 17: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async) {
          var util = _dereq_2("./util");
          var canEvaluate2 = util.canEvaluate;
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var reject;
          if (false) {
            if (canEvaluate2) {
              var thenCallback = function(i2) {
                return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i2));
              };
              var promiseSetter = function(i2) {
                return new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, i2));
              };
              var generateHolderClass = function(total) {
                var props = new Array(total);
                for (var i2 = 0; i2 < props.length; ++i2) {
                  props[i2] = "this.p" + (i2 + 1);
                }
                var assignment = props.join(" = ") + " = null;";
                var cancellationCode = "var promise;\n" + props.map(function(prop) {
                  return "                                                         \n                promise = " + prop + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ";
                }).join("\n");
                var passedArguments = props.join(", ");
                var name = "Holder$" + total;
                var code = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
                code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
                return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch2, errorObj2, Promise2, async);
              };
              var holderClasses = [];
              var thenCallbacks = [];
              var promiseSetters = [];
              for (var i = 0; i < 8; ++i) {
                holderClasses.push(generateHolderClass(i + 1));
                thenCallbacks.push(thenCallback(i + 1));
                promiseSetters.push(promiseSetter(i + 1));
              }
              reject = function(reason) {
                this._reject(reason);
              };
            }
          }
          Promise2.join = function() {
            var last = arguments.length - 1;
            var fn;
            if (last > 0 && typeof arguments[last] === "function") {
              fn = arguments[last];
              if (false) {
                if (last <= 8 && canEvaluate2) {
                  var ret2 = new Promise2(INTERNAL);
                  ret2._captureStackTrace();
                  var HolderClass = holderClasses[last - 1];
                  var holder = new HolderClass(fn);
                  var callbacks = thenCallbacks;
                  for (var i2 = 0; i2 < last; ++i2) {
                    var maybePromise = tryConvertToPromise(arguments[i2], ret2);
                    if (maybePromise instanceof Promise2) {
                      maybePromise = maybePromise._target();
                      var bitField = maybePromise._bitField;
                      ;
                      if ((bitField & 50397184) === 0) {
                        maybePromise._then(
                          callbacks[i2],
                          reject,
                          void 0,
                          ret2,
                          holder
                        );
                        promiseSetters[i2](maybePromise, holder);
                        holder.asyncNeeded = false;
                      } else if ((bitField & 33554432) !== 0) {
                        callbacks[i2].call(
                          ret2,
                          maybePromise._value(),
                          holder
                        );
                      } else if ((bitField & 16777216) !== 0) {
                        ret2._reject(maybePromise._reason());
                      } else {
                        ret2._cancel();
                      }
                    } else {
                      callbacks[i2].call(ret2, maybePromise, holder);
                    }
                  }
                  if (!ret2._isFateSealed()) {
                    if (holder.asyncNeeded) {
                      var context = Promise2._getContext();
                      holder.fn = util.contextBind(context, holder.fn);
                    }
                    ret2._setAsyncGuaranteed();
                    ret2._setOnCancel(holder);
                  }
                  return ret2;
                }
              }
            }
            var args = [].slice.call(arguments);
            ;
            if (fn)
              args.pop();
            var ret2 = new PromiseArray(args).promise();
            return fn !== void 0 ? ret2.spread(fn) : ret2;
          };
        };
      }, { "./util": 36 }], 18: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
          var util = _dereq_2("./util");
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          var async = Promise2._async;
          function MappingPromiseArray(promises, fn, limit, _filter) {
            this.constructor$(promises);
            this._promise._captureStackTrace();
            var context = Promise2._getContext();
            this._callback = util.contextBind(context, fn);
            this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
            this._limit = limit;
            this._inFlight = 0;
            this._queue = [];
            async.invoke(this._asyncInit, this, void 0);
            if (util.isArray(promises)) {
              for (var i = 0; i < promises.length; ++i) {
                var maybePromise = promises[i];
                if (maybePromise instanceof Promise2) {
                  maybePromise.suppressUnhandledRejections();
                }
              }
            }
          }
          util.inherits(MappingPromiseArray, PromiseArray);
          MappingPromiseArray.prototype._asyncInit = function() {
            this._init$(void 0, -2);
          };
          MappingPromiseArray.prototype._init = function() {
          };
          MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var values = this._values;
            var length = this.length();
            var preservedValues = this._preservedValues;
            var limit = this._limit;
            if (index < 0) {
              index = index * -1 - 1;
              values[index] = value;
              if (limit >= 1) {
                this._inFlight--;
                this._drainQueue();
                if (this._isResolved())
                  return true;
              }
            } else {
              if (limit >= 1 && this._inFlight >= limit) {
                values[index] = value;
                this._queue.push(index);
                return false;
              }
              if (preservedValues !== null)
                preservedValues[index] = value;
              var promise = this._promise;
              var callback = this._callback;
              var receiver2 = promise._boundValue();
              promise._pushContext();
              var ret2 = tryCatch2(callback).call(receiver2, value, index, length);
              var promiseCreated = promise._popContext();
              debug.checkForgottenReturns(
                ret2,
                promiseCreated,
                preservedValues !== null ? "Promise.filter" : "Promise.map",
                promise
              );
              if (ret2 === errorObj2) {
                this._reject(ret2.e);
                return true;
              }
              var maybePromise = tryConvertToPromise(ret2, this._promise);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                ;
                if ((bitField & 50397184) === 0) {
                  if (limit >= 1)
                    this._inFlight++;
                  values[index] = maybePromise;
                  maybePromise._proxy(this, (index + 1) * -1);
                  return false;
                } else if ((bitField & 33554432) !== 0) {
                  ret2 = maybePromise._value();
                } else if ((bitField & 16777216) !== 0) {
                  this._reject(maybePromise._reason());
                  return true;
                } else {
                  this._cancel();
                  return true;
                }
              }
              values[index] = ret2;
            }
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= length) {
              if (preservedValues !== null) {
                this._filter(values, preservedValues);
              } else {
                this._resolve(values);
              }
              return true;
            }
            return false;
          };
          MappingPromiseArray.prototype._drainQueue = function() {
            var queue = this._queue;
            var limit = this._limit;
            var values = this._values;
            while (queue.length > 0 && this._inFlight < limit) {
              if (this._isResolved())
                return;
              var index = queue.pop();
              this._promiseFulfilled(values[index], index);
            }
          };
          MappingPromiseArray.prototype._filter = function(booleans, values) {
            var len = values.length;
            var ret2 = new Array(len);
            var j = 0;
            for (var i = 0; i < len; ++i) {
              if (booleans[i])
                ret2[j++] = values[i];
            }
            ret2.length = j;
            this._resolve(ret2);
          };
          MappingPromiseArray.prototype.preservedValues = function() {
            return this._preservedValues;
          };
          function map(promises, fn, options, _filter) {
            if (typeof fn !== "function") {
              return apiRejection("expecting a function but got " + util.classString(fn));
            }
            var limit = 0;
            if (options !== void 0) {
              if (typeof options === "object" && options !== null) {
                if (typeof options.concurrency !== "number") {
                  return Promise2.reject(
                    new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency))
                  );
                }
                limit = options.concurrency;
              } else {
                return Promise2.reject(new TypeError(
                  "options argument must be an object but it is " + util.classString(options)
                ));
              }
            }
            limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
            return new MappingPromiseArray(promises, fn, limit, _filter).promise();
          }
          Promise2.prototype.map = function(fn, options) {
            return map(this, fn, options, null);
          };
          Promise2.map = function(promises, fn, options, _filter) {
            return map(promises, fn, options, _filter);
          };
        };
      }, { "./util": 36 }], 19: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug) {
          var util = _dereq_2("./util");
          var tryCatch2 = util.tryCatch;
          Promise2.method = function(fn) {
            if (typeof fn !== "function") {
              throw new Promise2.TypeError("expecting a function but got " + util.classString(fn));
            }
            return function() {
              var ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              ret2._pushContext();
              var value = tryCatch2(fn).apply(this, arguments);
              var promiseCreated = ret2._popContext();
              debug.checkForgottenReturns(
                value,
                promiseCreated,
                "Promise.method",
                ret2
              );
              ret2._resolveFromSyncValue(value);
              return ret2;
            };
          };
          Promise2.attempt = Promise2["try"] = function(fn) {
            if (typeof fn !== "function") {
              return apiRejection("expecting a function but got " + util.classString(fn));
            }
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            ret2._pushContext();
            var value;
            if (arguments.length > 1) {
              debug.deprecated("calling Promise.try with more than 1 argument");
              var arg = arguments[1];
              var ctx = arguments[2];
              value = util.isArray(arg) ? tryCatch2(fn).apply(ctx, arg) : tryCatch2(fn).call(ctx, arg);
            } else {
              value = tryCatch2(fn)();
            }
            var promiseCreated = ret2._popContext();
            debug.checkForgottenReturns(
              value,
              promiseCreated,
              "Promise.try",
              ret2
            );
            ret2._resolveFromSyncValue(value);
            return ret2;
          };
          Promise2.prototype._resolveFromSyncValue = function(value) {
            if (value === util.errorObj) {
              this._rejectCallback(value.e, false);
            } else {
              this._resolveCallback(value, true);
            }
          };
        };
      }, { "./util": 36 }], 20: [function(_dereq_2, module2, exports2) {
        "use strict";
        var util = _dereq_2("./util");
        var maybeWrapAsError2 = util.maybeWrapAsError;
        var errors = _dereq_2("./errors");
        var OperationalError = errors.OperationalError;
        var es52 = _dereq_2("./es5");
        function isUntypedError(obj2) {
          return obj2 instanceof Error && es52.getPrototypeOf(obj2) === Error.prototype;
        }
        var rErrorKey = /^(?:name|message|stack|cause)$/;
        function wrapAsOperationalError(obj2) {
          var ret2;
          if (isUntypedError(obj2)) {
            ret2 = new OperationalError(obj2);
            ret2.name = obj2.name;
            ret2.message = obj2.message;
            ret2.stack = obj2.stack;
            var keys = es52.keys(obj2);
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (!rErrorKey.test(key)) {
                ret2[key] = obj2[key];
              }
            }
            return ret2;
          }
          util.markAsOriginatingFromRejection(obj2);
          return obj2;
        }
        function nodebackForPromise(promise, multiArgs) {
          return function(err, value) {
            if (promise === null)
              return;
            if (err) {
              var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
              promise._attachExtraTrace(wrapped);
              promise._reject(wrapped);
            } else if (!multiArgs) {
              promise._fulfill(value);
            } else {
              var args = [].slice.call(arguments, 1);
              ;
              promise._fulfill(args);
            }
            promise = null;
          };
        }
        module2.exports = nodebackForPromise;
      }, { "./errors": 12, "./es5": 13, "./util": 36 }], 21: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          var util = _dereq_2("./util");
          var async = Promise2._async;
          var tryCatch2 = util.tryCatch;
          var errorObj2 = util.errorObj;
          function spreadAdapter(val, nodeback) {
            var promise = this;
            if (!util.isArray(val))
              return successAdapter.call(promise, val, nodeback);
            var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          function successAdapter(val, nodeback) {
            var promise = this;
            var receiver2 = promise._boundValue();
            var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver2, null) : tryCatch2(nodeback).call(receiver2, null, val);
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          function errorAdapter(reason, nodeback) {
            var promise = this;
            if (!reason) {
              var newReason = new Error(reason + "");
              newReason.cause = reason;
              reason = newReason;
            }
            var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
            if (ret2 === errorObj2) {
              async.throwLater(ret2.e);
            }
          }
          Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
            if (typeof nodeback == "function") {
              var adapter = successAdapter;
              if (options !== void 0 && Object(options).spread) {
                adapter = spreadAdapter;
              }
              this._then(
                adapter,
                errorAdapter,
                void 0,
                this,
                nodeback
              );
            }
            return this;
          };
        };
      }, { "./util": 36 }], 22: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function() {
          var makeSelfResolutionError = function() {
            return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
          };
          var reflectHandler2 = function() {
            return new Promise2.PromiseInspection(this._target());
          };
          var apiRejection = function(msg) {
            return Promise2.reject(new TypeError2(msg));
          };
          function Proxyable() {
          }
          var UNDEFINED_BINDING = {};
          var util = _dereq_2("./util");
          util.setReflectHandler(reflectHandler2);
          var getDomain = function() {
            var domain = process.domain;
            if (domain === void 0) {
              return null;
            }
            return domain;
          };
          var getContextDefault = function() {
            return null;
          };
          var getContextDomain = function() {
            return {
              domain: getDomain(),
              async: null
            };
          };
          var AsyncResource = util.isNode && util.nodeSupportsAsyncResource ? _dereq_2("async_hooks").AsyncResource : null;
          var getContextAsyncHooks = function() {
            return {
              domain: getDomain(),
              async: new AsyncResource("Bluebird::Promise")
            };
          };
          var getContext = util.isNode ? getContextDomain : getContextDefault;
          util.notEnumerableProp(Promise2, "_getContext", getContext);
          var enableAsyncHooks = function() {
            getContext = getContextAsyncHooks;
            util.notEnumerableProp(Promise2, "_getContext", getContextAsyncHooks);
          };
          var disableAsyncHooks = function() {
            getContext = getContextDomain;
            util.notEnumerableProp(Promise2, "_getContext", getContextDomain);
          };
          var es52 = _dereq_2("./es5");
          var Async = _dereq_2("./async");
          var async = new Async();
          es52.defineProperty(Promise2, "_async", { value: async });
          var errors = _dereq_2("./errors");
          var TypeError2 = Promise2.TypeError = errors.TypeError;
          Promise2.RangeError = errors.RangeError;
          var CancellationError = Promise2.CancellationError = errors.CancellationError;
          Promise2.TimeoutError = errors.TimeoutError;
          Promise2.OperationalError = errors.OperationalError;
          Promise2.RejectionError = errors.OperationalError;
          Promise2.AggregateError = errors.AggregateError;
          var INTERNAL = function() {
          };
          var APPLY = {};
          var NEXT_FILTER = {};
          var tryConvertToPromise = _dereq_2("./thenables")(Promise2, INTERNAL);
          var PromiseArray = _dereq_2("./promise_array")(
            Promise2,
            INTERNAL,
            tryConvertToPromise,
            apiRejection,
            Proxyable
          );
          var Context = _dereq_2("./context")(Promise2);
          var createContext = Context.create;
          var debug = _dereq_2("./debuggability")(
            Promise2,
            Context,
            enableAsyncHooks,
            disableAsyncHooks
          );
          var CapturedTrace = debug.CapturedTrace;
          var PassThroughHandlerContext = _dereq_2("./finally")(Promise2, tryConvertToPromise, NEXT_FILTER);
          var catchFilter = _dereq_2("./catch_filter")(NEXT_FILTER);
          var nodebackForPromise = _dereq_2("./nodeback");
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          function check(self2, executor) {
            if (self2 == null || self2.constructor !== Promise2) {
              throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
            }
            if (typeof executor !== "function") {
              throw new TypeError2("expecting a function but got " + util.classString(executor));
            }
          }
          function Promise2(executor) {
            if (executor !== INTERNAL) {
              check(this, executor);
            }
            this._bitField = 0;
            this._fulfillmentHandler0 = void 0;
            this._rejectionHandler0 = void 0;
            this._promise0 = void 0;
            this._receiver0 = void 0;
            this._resolveFromExecutor(executor);
            this._promiseCreated();
            this._fireEvent("promiseCreated", this);
          }
          Promise2.prototype.toString = function() {
            return "[object Promise]";
          };
          Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
            var len = arguments.length;
            if (len > 1) {
              var catchInstances = new Array(len - 1), j = 0, i;
              for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (util.isObject(item)) {
                  catchInstances[j++] = item;
                } else {
                  return apiRejection("Catch statement predicate: expecting an object but got " + util.classString(item));
                }
              }
              catchInstances.length = j;
              fn = arguments[i];
              if (typeof fn !== "function") {
                throw new TypeError2("The last argument to .catch() must be a function, got " + util.toString(fn));
              }
              return this.then(void 0, catchFilter(catchInstances, fn, this));
            }
            return this.then(void 0, fn);
          };
          Promise2.prototype.reflect = function() {
            return this._then(
              reflectHandler2,
              reflectHandler2,
              void 0,
              this,
              void 0
            );
          };
          Promise2.prototype.then = function(didFulfill, didReject) {
            if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
              var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
              if (arguments.length > 1) {
                msg += ", " + util.classString(didReject);
              }
              this._warn(msg);
            }
            return this._then(didFulfill, didReject, void 0, void 0, void 0);
          };
          Promise2.prototype.done = function(didFulfill, didReject) {
            var promise = this._then(didFulfill, didReject, void 0, void 0, void 0);
            promise._setIsFinal();
          };
          Promise2.prototype.spread = function(fn) {
            if (typeof fn !== "function") {
              return apiRejection("expecting a function but got " + util.classString(fn));
            }
            return this.all()._then(fn, void 0, void 0, APPLY, void 0);
          };
          Promise2.prototype.toJSON = function() {
            var ret2 = {
              isFulfilled: false,
              isRejected: false,
              fulfillmentValue: void 0,
              rejectionReason: void 0
            };
            if (this.isFulfilled()) {
              ret2.fulfillmentValue = this.value();
              ret2.isFulfilled = true;
            } else if (this.isRejected()) {
              ret2.rejectionReason = this.reason();
              ret2.isRejected = true;
            }
            return ret2;
          };
          Promise2.prototype.all = function() {
            if (arguments.length > 0) {
              this._warn(".all() was passed arguments but it does not take any");
            }
            return new PromiseArray(this).promise();
          };
          Promise2.prototype.error = function(fn) {
            return this.caught(util.originatesFromRejection, fn);
          };
          Promise2.getNewLibraryCopy = module2.exports;
          Promise2.is = function(val) {
            return val instanceof Promise2;
          };
          Promise2.fromNode = Promise2.fromCallback = function(fn) {
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
            var result = tryCatch2(fn)(nodebackForPromise(ret2, multiArgs));
            if (result === errorObj2) {
              ret2._rejectCallback(result.e, true);
            }
            if (!ret2._isFateSealed())
              ret2._setAsyncGuaranteed();
            return ret2;
          };
          Promise2.all = function(promises) {
            return new PromiseArray(promises).promise();
          };
          Promise2.cast = function(obj2) {
            var ret2 = tryConvertToPromise(obj2);
            if (!(ret2 instanceof Promise2)) {
              ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              ret2._setFulfilled();
              ret2._rejectionHandler0 = obj2;
            }
            return ret2;
          };
          Promise2.resolve = Promise2.fulfilled = Promise2.cast;
          Promise2.reject = Promise2.rejected = function(reason) {
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            ret2._rejectCallback(reason, true);
            return ret2;
          };
          Promise2.setScheduler = function(fn) {
            if (typeof fn !== "function") {
              throw new TypeError2("expecting a function but got " + util.classString(fn));
            }
            return async.setScheduler(fn);
          };
          Promise2.prototype._then = function(didFulfill, didReject, _, receiver2, internalData) {
            var haveInternalData = internalData !== void 0;
            var promise = haveInternalData ? internalData : new Promise2(INTERNAL);
            var target = this._target();
            var bitField = target._bitField;
            if (!haveInternalData) {
              promise._propagateFrom(this, 3);
              promise._captureStackTrace();
              if (receiver2 === void 0 && (this._bitField & 2097152) !== 0) {
                if (!((bitField & 50397184) === 0)) {
                  receiver2 = this._boundValue();
                } else {
                  receiver2 = target === this ? void 0 : this._boundTo;
                }
              }
              this._fireEvent("promiseChained", this, promise);
            }
            var context = getContext();
            if (!((bitField & 50397184) === 0)) {
              var handler, value, settler = target._settlePromiseCtx;
              if ((bitField & 33554432) !== 0) {
                value = target._rejectionHandler0;
                handler = didFulfill;
              } else if ((bitField & 16777216) !== 0) {
                value = target._fulfillmentHandler0;
                handler = didReject;
                target._unsetRejectionIsUnhandled();
              } else {
                settler = target._settlePromiseLateCancellationObserver;
                value = new CancellationError("late cancellation observer");
                target._attachExtraTrace(value);
                handler = didReject;
              }
              async.invoke(settler, target, {
                handler: util.contextBind(context, handler),
                promise,
                receiver: receiver2,
                value
              });
            } else {
              target._addCallbacks(
                didFulfill,
                didReject,
                promise,
                receiver2,
                context
              );
            }
            return promise;
          };
          Promise2.prototype._length = function() {
            return this._bitField & 65535;
          };
          Promise2.prototype._isFateSealed = function() {
            return (this._bitField & 117506048) !== 0;
          };
          Promise2.prototype._isFollowing = function() {
            return (this._bitField & 67108864) === 67108864;
          };
          Promise2.prototype._setLength = function(len) {
            this._bitField = this._bitField & -65536 | len & 65535;
          };
          Promise2.prototype._setFulfilled = function() {
            this._bitField = this._bitField | 33554432;
            this._fireEvent("promiseFulfilled", this);
          };
          Promise2.prototype._setRejected = function() {
            this._bitField = this._bitField | 16777216;
            this._fireEvent("promiseRejected", this);
          };
          Promise2.prototype._setFollowing = function() {
            this._bitField = this._bitField | 67108864;
            this._fireEvent("promiseResolved", this);
          };
          Promise2.prototype._setIsFinal = function() {
            this._bitField = this._bitField | 4194304;
          };
          Promise2.prototype._isFinal = function() {
            return (this._bitField & 4194304) > 0;
          };
          Promise2.prototype._unsetCancelled = function() {
            this._bitField = this._bitField & ~65536;
          };
          Promise2.prototype._setCancelled = function() {
            this._bitField = this._bitField | 65536;
            this._fireEvent("promiseCancelled", this);
          };
          Promise2.prototype._setWillBeCancelled = function() {
            this._bitField = this._bitField | 8388608;
          };
          Promise2.prototype._setAsyncGuaranteed = function() {
            if (async.hasCustomScheduler())
              return;
            var bitField = this._bitField;
            this._bitField = bitField | (bitField & 536870912) >> 2 ^ 134217728;
          };
          Promise2.prototype._setNoAsyncGuarantee = function() {
            this._bitField = (this._bitField | 536870912) & ~134217728;
          };
          Promise2.prototype._receiverAt = function(index) {
            var ret2 = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
            if (ret2 === UNDEFINED_BINDING) {
              return void 0;
            } else if (ret2 === void 0 && this._isBound()) {
              return this._boundValue();
            }
            return ret2;
          };
          Promise2.prototype._promiseAt = function(index) {
            return this[index * 4 - 4 + 2];
          };
          Promise2.prototype._fulfillmentHandlerAt = function(index) {
            return this[index * 4 - 4 + 0];
          };
          Promise2.prototype._rejectionHandlerAt = function(index) {
            return this[index * 4 - 4 + 1];
          };
          Promise2.prototype._boundValue = function() {
          };
          Promise2.prototype._migrateCallback0 = function(follower) {
            var bitField = follower._bitField;
            var fulfill = follower._fulfillmentHandler0;
            var reject = follower._rejectionHandler0;
            var promise = follower._promise0;
            var receiver2 = follower._receiverAt(0);
            if (receiver2 === void 0)
              receiver2 = UNDEFINED_BINDING;
            this._addCallbacks(fulfill, reject, promise, receiver2, null);
          };
          Promise2.prototype._migrateCallbackAt = function(follower, index) {
            var fulfill = follower._fulfillmentHandlerAt(index);
            var reject = follower._rejectionHandlerAt(index);
            var promise = follower._promiseAt(index);
            var receiver2 = follower._receiverAt(index);
            if (receiver2 === void 0)
              receiver2 = UNDEFINED_BINDING;
            this._addCallbacks(fulfill, reject, promise, receiver2, null);
          };
          Promise2.prototype._addCallbacks = function(fulfill, reject, promise, receiver2, context) {
            var index = this._length();
            if (index >= 65535 - 4) {
              index = 0;
              this._setLength(0);
            }
            if (index === 0) {
              this._promise0 = promise;
              this._receiver0 = receiver2;
              if (typeof fulfill === "function") {
                this._fulfillmentHandler0 = util.contextBind(context, fulfill);
              }
              if (typeof reject === "function") {
                this._rejectionHandler0 = util.contextBind(context, reject);
              }
            } else {
              var base = index * 4 - 4;
              this[base + 2] = promise;
              this[base + 3] = receiver2;
              if (typeof fulfill === "function") {
                this[base + 0] = util.contextBind(context, fulfill);
              }
              if (typeof reject === "function") {
                this[base + 1] = util.contextBind(context, reject);
              }
            }
            this._setLength(index + 1);
            return index;
          };
          Promise2.prototype._proxy = function(proxyable, arg) {
            this._addCallbacks(void 0, void 0, arg, proxyable, null);
          };
          Promise2.prototype._resolveCallback = function(value, shouldBind) {
            if ((this._bitField & 117506048) !== 0)
              return;
            if (value === this)
              return this._rejectCallback(makeSelfResolutionError(), false);
            var maybePromise = tryConvertToPromise(value, this);
            if (!(maybePromise instanceof Promise2))
              return this._fulfill(value);
            if (shouldBind)
              this._propagateFrom(maybePromise, 2);
            var promise = maybePromise._target();
            if (promise === this) {
              this._reject(makeSelfResolutionError());
              return;
            }
            var bitField = promise._bitField;
            if ((bitField & 50397184) === 0) {
              var len = this._length();
              if (len > 0)
                promise._migrateCallback0(this);
              for (var i = 1; i < len; ++i) {
                promise._migrateCallbackAt(this, i);
              }
              this._setFollowing();
              this._setLength(0);
              this._setFollowee(maybePromise);
            } else if ((bitField & 33554432) !== 0) {
              this._fulfill(promise._value());
            } else if ((bitField & 16777216) !== 0) {
              this._reject(promise._reason());
            } else {
              var reason = new CancellationError("late cancellation observer");
              promise._attachExtraTrace(reason);
              this._reject(reason);
            }
          };
          Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
            var trace = util.ensureErrorObject(reason);
            var hasStack = trace === reason;
            if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
              var message = "a promise was rejected with a non-error: " + util.classString(reason);
              this._warn(message, true);
            }
            this._attachExtraTrace(trace, synchronous ? hasStack : false);
            this._reject(reason);
          };
          Promise2.prototype._resolveFromExecutor = function(executor) {
            if (executor === INTERNAL)
              return;
            var promise = this;
            this._captureStackTrace();
            this._pushContext();
            var synchronous = true;
            var r = this._execute(executor, function(value) {
              promise._resolveCallback(value);
            }, function(reason) {
              promise._rejectCallback(reason, synchronous);
            });
            synchronous = false;
            this._popContext();
            if (r !== void 0) {
              promise._rejectCallback(r, true);
            }
          };
          Promise2.prototype._settlePromiseFromHandler = function(handler, receiver2, value, promise) {
            var bitField = promise._bitField;
            if ((bitField & 65536) !== 0)
              return;
            promise._pushContext();
            var x;
            if (receiver2 === APPLY) {
              if (!value || typeof value.length !== "number") {
                x = errorObj2;
                x.e = new TypeError2("cannot .spread() a non-array: " + util.classString(value));
              } else {
                x = tryCatch2(handler).apply(this._boundValue(), value);
              }
            } else {
              x = tryCatch2(handler).call(receiver2, value);
            }
            var promiseCreated = promise._popContext();
            bitField = promise._bitField;
            if ((bitField & 65536) !== 0)
              return;
            if (x === NEXT_FILTER) {
              promise._reject(value);
            } else if (x === errorObj2) {
              promise._rejectCallback(x.e, false);
            } else {
              debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
              promise._resolveCallback(x);
            }
          };
          Promise2.prototype._target = function() {
            var ret2 = this;
            while (ret2._isFollowing())
              ret2 = ret2._followee();
            return ret2;
          };
          Promise2.prototype._followee = function() {
            return this._rejectionHandler0;
          };
          Promise2.prototype._setFollowee = function(promise) {
            this._rejectionHandler0 = promise;
          };
          Promise2.prototype._settlePromise = function(promise, handler, receiver2, value) {
            var isPromise = promise instanceof Promise2;
            var bitField = this._bitField;
            var asyncGuaranteed = (bitField & 134217728) !== 0;
            if ((bitField & 65536) !== 0) {
              if (isPromise)
                promise._invokeInternalOnCancel();
              if (receiver2 instanceof PassThroughHandlerContext && receiver2.isFinallyHandler()) {
                receiver2.cancelPromise = promise;
                if (tryCatch2(handler).call(receiver2, value) === errorObj2) {
                  promise._reject(errorObj2.e);
                }
              } else if (handler === reflectHandler2) {
                promise._fulfill(reflectHandler2.call(receiver2));
              } else if (receiver2 instanceof Proxyable) {
                receiver2._promiseCancelled(promise);
              } else if (isPromise || promise instanceof PromiseArray) {
                promise._cancel();
              } else {
                receiver2.cancel();
              }
            } else if (typeof handler === "function") {
              if (!isPromise) {
                handler.call(receiver2, value, promise);
              } else {
                if (asyncGuaranteed)
                  promise._setAsyncGuaranteed();
                this._settlePromiseFromHandler(handler, receiver2, value, promise);
              }
            } else if (receiver2 instanceof Proxyable) {
              if (!receiver2._isResolved()) {
                if ((bitField & 33554432) !== 0) {
                  receiver2._promiseFulfilled(value, promise);
                } else {
                  receiver2._promiseRejected(value, promise);
                }
              }
            } else if (isPromise) {
              if (asyncGuaranteed)
                promise._setAsyncGuaranteed();
              if ((bitField & 33554432) !== 0) {
                promise._fulfill(value);
              } else {
                promise._reject(value);
              }
            }
          };
          Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
            var handler = ctx.handler;
            var promise = ctx.promise;
            var receiver2 = ctx.receiver;
            var value = ctx.value;
            if (typeof handler === "function") {
              if (!(promise instanceof Promise2)) {
                handler.call(receiver2, value, promise);
              } else {
                this._settlePromiseFromHandler(handler, receiver2, value, promise);
              }
            } else if (promise instanceof Promise2) {
              promise._reject(value);
            }
          };
          Promise2.prototype._settlePromiseCtx = function(ctx) {
            this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
          };
          Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
            var promise = this._promise0;
            var receiver2 = this._receiverAt(0);
            this._promise0 = void 0;
            this._receiver0 = void 0;
            this._settlePromise(promise, handler, receiver2, value);
          };
          Promise2.prototype._clearCallbackDataAtIndex = function(index) {
            var base = index * 4 - 4;
            this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
          };
          Promise2.prototype._fulfill = function(value) {
            var bitField = this._bitField;
            if ((bitField & 117506048) >>> 16)
              return;
            if (value === this) {
              var err = makeSelfResolutionError();
              this._attachExtraTrace(err);
              return this._reject(err);
            }
            this._setFulfilled();
            this._rejectionHandler0 = value;
            if ((bitField & 65535) > 0) {
              if ((bitField & 134217728) !== 0) {
                this._settlePromises();
              } else {
                async.settlePromises(this);
              }
              this._dereferenceTrace();
            }
          };
          Promise2.prototype._reject = function(reason) {
            var bitField = this._bitField;
            if ((bitField & 117506048) >>> 16)
              return;
            this._setRejected();
            this._fulfillmentHandler0 = reason;
            if (this._isFinal()) {
              return async.fatalError(reason, util.isNode);
            }
            if ((bitField & 65535) > 0) {
              async.settlePromises(this);
            } else {
              this._ensurePossibleRejectionHandled();
            }
          };
          Promise2.prototype._fulfillPromises = function(len, value) {
            for (var i = 1; i < len; i++) {
              var handler = this._fulfillmentHandlerAt(i);
              var promise = this._promiseAt(i);
              var receiver2 = this._receiverAt(i);
              this._clearCallbackDataAtIndex(i);
              this._settlePromise(promise, handler, receiver2, value);
            }
          };
          Promise2.prototype._rejectPromises = function(len, reason) {
            for (var i = 1; i < len; i++) {
              var handler = this._rejectionHandlerAt(i);
              var promise = this._promiseAt(i);
              var receiver2 = this._receiverAt(i);
              this._clearCallbackDataAtIndex(i);
              this._settlePromise(promise, handler, receiver2, reason);
            }
          };
          Promise2.prototype._settlePromises = function() {
            var bitField = this._bitField;
            var len = bitField & 65535;
            if (len > 0) {
              if ((bitField & 16842752) !== 0) {
                var reason = this._fulfillmentHandler0;
                this._settlePromise0(this._rejectionHandler0, reason, bitField);
                this._rejectPromises(len, reason);
              } else {
                var value = this._rejectionHandler0;
                this._settlePromise0(this._fulfillmentHandler0, value, bitField);
                this._fulfillPromises(len, value);
              }
              this._setLength(0);
            }
            this._clearCancellationData();
          };
          Promise2.prototype._settledValue = function() {
            var bitField = this._bitField;
            if ((bitField & 33554432) !== 0) {
              return this._rejectionHandler0;
            } else if ((bitField & 16777216) !== 0) {
              return this._fulfillmentHandler0;
            }
          };
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            es52.defineProperty(Promise2.prototype, Symbol.toStringTag, {
              get: function() {
                return "Object";
              }
            });
          }
          function deferResolve(v) {
            this.promise._resolveCallback(v);
          }
          function deferReject(v) {
            this.promise._rejectCallback(v, false);
          }
          Promise2.defer = Promise2.pending = function() {
            debug.deprecated("Promise.defer", "new Promise");
            var promise = new Promise2(INTERNAL);
            return {
              promise,
              resolve: deferResolve,
              reject: deferReject
            };
          };
          util.notEnumerableProp(
            Promise2,
            "_makeSelfResolutionError",
            makeSelfResolutionError
          );
          _dereq_2("./method")(
            Promise2,
            INTERNAL,
            tryConvertToPromise,
            apiRejection,
            debug
          );
          _dereq_2("./bind")(Promise2, INTERNAL, tryConvertToPromise, debug);
          _dereq_2("./cancel")(Promise2, PromiseArray, apiRejection, debug);
          _dereq_2("./direct_resolve")(Promise2);
          _dereq_2("./synchronous_inspection")(Promise2);
          _dereq_2("./join")(
            Promise2,
            PromiseArray,
            tryConvertToPromise,
            INTERNAL,
            async
          );
          Promise2.Promise = Promise2;
          Promise2.version = "3.7.2";
          _dereq_2("./call_get.js")(Promise2);
          _dereq_2("./generators.js")(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
          _dereq_2("./map.js")(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
          _dereq_2("./nodeify.js")(Promise2);
          _dereq_2("./promisify.js")(Promise2, INTERNAL);
          _dereq_2("./props.js")(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
          _dereq_2("./race.js")(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
          _dereq_2("./reduce.js")(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
          _dereq_2("./settle.js")(Promise2, PromiseArray, debug);
          _dereq_2("./some.js")(Promise2, PromiseArray, apiRejection);
          _dereq_2("./timers.js")(Promise2, INTERNAL, debug);
          _dereq_2("./using.js")(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
          _dereq_2("./any.js")(Promise2);
          _dereq_2("./each.js")(Promise2, INTERNAL);
          _dereq_2("./filter.js")(Promise2, INTERNAL);
          util.toFastProperties(Promise2);
          util.toFastProperties(Promise2.prototype);
          function fillTypes(value) {
            var p = new Promise2(INTERNAL);
            p._fulfillmentHandler0 = value;
            p._rejectionHandler0 = value;
            p._promise0 = value;
            p._receiver0 = value;
          }
          fillTypes({ a: 1 });
          fillTypes({ b: 2 });
          fillTypes({ c: 3 });
          fillTypes(1);
          fillTypes(function() {
          });
          fillTypes(void 0);
          fillTypes(false);
          fillTypes(new Promise2(INTERNAL));
          debug.setBounds(Async.firstLineError, util.lastLineError);
          return Promise2;
        };
      }, { "./any.js": 1, "./async": 2, "./bind": 3, "./call_get.js": 5, "./cancel": 6, "./catch_filter": 7, "./context": 8, "./debuggability": 9, "./direct_resolve": 10, "./each.js": 11, "./errors": 12, "./es5": 13, "./filter.js": 14, "./finally": 15, "./generators.js": 16, "./join": 17, "./map.js": 18, "./method": 19, "./nodeback": 20, "./nodeify.js": 21, "./promise_array": 23, "./promisify.js": 24, "./props.js": 25, "./race.js": 27, "./reduce.js": 28, "./settle.js": 30, "./some.js": 31, "./synchronous_inspection": 32, "./thenables": 33, "./timers.js": 34, "./using.js": 35, "./util": 36, "async_hooks": void 0 }], 23: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
          var util = _dereq_2("./util");
          var isArray = util.isArray;
          function toResolutionValue(val) {
            switch (val) {
              case -2:
                return [];
              case -3:
                return {};
              case -6:
                return /* @__PURE__ */ new Map();
            }
          }
          function PromiseArray(values) {
            var promise = this._promise = new Promise2(INTERNAL);
            if (values instanceof Promise2) {
              promise._propagateFrom(values, 3);
              values.suppressUnhandledRejections();
            }
            promise._setOnCancel(this);
            this._values = values;
            this._length = 0;
            this._totalResolved = 0;
            this._init(void 0, -2);
          }
          util.inherits(PromiseArray, Proxyable);
          PromiseArray.prototype.length = function() {
            return this._length;
          };
          PromiseArray.prototype.promise = function() {
            return this._promise;
          };
          PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
            var values = tryConvertToPromise(this._values, this._promise);
            if (values instanceof Promise2) {
              values = values._target();
              var bitField = values._bitField;
              ;
              this._values = values;
              if ((bitField & 50397184) === 0) {
                this._promise._setAsyncGuaranteed();
                return values._then(
                  init,
                  this._reject,
                  void 0,
                  this,
                  resolveValueIfEmpty
                );
              } else if ((bitField & 33554432) !== 0) {
                values = values._value();
              } else if ((bitField & 16777216) !== 0) {
                return this._reject(values._reason());
              } else {
                return this._cancel();
              }
            }
            values = util.asArray(values);
            if (values === null) {
              var err = apiRejection(
                "expecting an array or an iterable object but got " + util.classString(values)
              ).reason();
              this._promise._rejectCallback(err, false);
              return;
            }
            if (values.length === 0) {
              if (resolveValueIfEmpty === -5) {
                this._resolveEmptyArray();
              } else {
                this._resolve(toResolutionValue(resolveValueIfEmpty));
              }
              return;
            }
            this._iterate(values);
          };
          PromiseArray.prototype._iterate = function(values) {
            var len = this.getActualLength(values.length);
            this._length = len;
            this._values = this.shouldCopyValues() ? new Array(len) : this._values;
            var result = this._promise;
            var isResolved = false;
            var bitField = null;
            for (var i = 0; i < len; ++i) {
              var maybePromise = tryConvertToPromise(values[i], result);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                bitField = maybePromise._bitField;
              } else {
                bitField = null;
              }
              if (isResolved) {
                if (bitField !== null) {
                  maybePromise.suppressUnhandledRejections();
                }
              } else if (bitField !== null) {
                if ((bitField & 50397184) === 0) {
                  maybePromise._proxy(this, i);
                  this._values[i] = maybePromise;
                } else if ((bitField & 33554432) !== 0) {
                  isResolved = this._promiseFulfilled(maybePromise._value(), i);
                } else if ((bitField & 16777216) !== 0) {
                  isResolved = this._promiseRejected(maybePromise._reason(), i);
                } else {
                  isResolved = this._promiseCancelled(i);
                }
              } else {
                isResolved = this._promiseFulfilled(maybePromise, i);
              }
            }
            if (!isResolved)
              result._setAsyncGuaranteed();
          };
          PromiseArray.prototype._isResolved = function() {
            return this._values === null;
          };
          PromiseArray.prototype._resolve = function(value) {
            this._values = null;
            this._promise._fulfill(value);
          };
          PromiseArray.prototype._cancel = function() {
            if (this._isResolved() || !this._promise._isCancellable())
              return;
            this._values = null;
            this._promise._cancel();
          };
          PromiseArray.prototype._reject = function(reason) {
            this._values = null;
            this._promise._rejectCallback(reason, false);
          };
          PromiseArray.prototype._promiseFulfilled = function(value, index) {
            this._values[index] = value;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              this._resolve(this._values);
              return true;
            }
            return false;
          };
          PromiseArray.prototype._promiseCancelled = function() {
            this._cancel();
            return true;
          };
          PromiseArray.prototype._promiseRejected = function(reason) {
            this._totalResolved++;
            this._reject(reason);
            return true;
          };
          PromiseArray.prototype._resultCancelled = function() {
            if (this._isResolved())
              return;
            var values = this._values;
            this._cancel();
            if (values instanceof Promise2) {
              values.cancel();
            } else {
              for (var i = 0; i < values.length; ++i) {
                if (values[i] instanceof Promise2) {
                  values[i].cancel();
                }
              }
            }
          };
          PromiseArray.prototype.shouldCopyValues = function() {
            return true;
          };
          PromiseArray.prototype.getActualLength = function(len) {
            return len;
          };
          return PromiseArray;
        };
      }, { "./util": 36 }], 24: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var THIS = {};
          var util = _dereq_2("./util");
          var nodebackForPromise = _dereq_2("./nodeback");
          var withAppended2 = util.withAppended;
          var maybeWrapAsError2 = util.maybeWrapAsError;
          var canEvaluate2 = util.canEvaluate;
          var TypeError2 = _dereq_2("./errors").TypeError;
          var defaultSuffix = "Async";
          var defaultPromisified = { __isPromisified__: true };
          var noCopyProps = [
            "arity",
            "length",
            "name",
            "arguments",
            "caller",
            "callee",
            "prototype",
            "__isPromisified__"
          ];
          var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
          var defaultFilter = function(name) {
            return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
          };
          function propsFilter(key) {
            return !noCopyPropsPattern.test(key);
          }
          function isPromisified(fn) {
            try {
              return fn.__isPromisified__ === true;
            } catch (e) {
              return false;
            }
          }
          function hasPromisified(obj2, key, suffix) {
            var val = util.getDataPropertyOrDefault(
              obj2,
              key + suffix,
              defaultPromisified
            );
            return val ? isPromisified(val) : false;
          }
          function checkValid(ret2, suffix, suffixRegexp) {
            for (var i = 0; i < ret2.length; i += 2) {
              var key = ret2[i];
              if (suffixRegexp.test(key)) {
                var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                for (var j = 0; j < ret2.length; j += 2) {
                  if (ret2[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
                  }
                }
              }
            }
          }
          function promisifiableMethods(obj2, suffix, suffixRegexp, filter) {
            var keys = util.inheritedDataKeys(obj2);
            var ret2 = [];
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              var value = obj2[key];
              var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj2);
              if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj2, key, suffix) && filter(key, value, obj2, passesDefaultFilter)) {
                ret2.push(key, value);
              }
            }
            checkValid(ret2, suffix, suffixRegexp);
            return ret2;
          }
          var escapeIdentRegex = function(str) {
            return str.replace(/([$])/, "\\$");
          };
          var makeNodePromisifiedEval;
          if (false) {
            var switchCaseArgumentOrder = function(likelyArgumentCount) {
              var ret2 = [likelyArgumentCount];
              var min = Math.max(0, likelyArgumentCount - 1 - 3);
              for (var i = likelyArgumentCount - 1; i >= min; --i) {
                ret2.push(i);
              }
              for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
                ret2.push(i);
              }
              return ret2;
            };
            var argumentSequence = function(argumentCount) {
              return util.filledRange(argumentCount, "_arg", "");
            };
            var parameterDeclaration = function(parameterCount2) {
              return util.filledRange(
                Math.max(parameterCount2, 3),
                "_arg",
                ""
              );
            };
            var parameterCount = function(fn) {
              if (typeof fn.length === "number") {
                return Math.max(Math.min(fn.length, 1023 + 1), 0);
              }
              return 0;
            };
            makeNodePromisifiedEval = function(callback, receiver2, originalName, fn, _, multiArgs) {
              var newParameterCount = Math.max(0, parameterCount(fn) - 1);
              var argumentOrder = switchCaseArgumentOrder(newParameterCount);
              var shouldProxyThis = typeof callback === "string" || receiver2 === THIS;
              function generateCallForArgumentCount(count) {
                var args = argumentSequence(count).join(", ");
                var comma = count > 0 ? ", " : "";
                var ret2;
                if (shouldProxyThis) {
                  ret2 = "ret = callback.call(this, {{args}}, nodeback); break;\n";
                } else {
                  ret2 = receiver2 === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
                }
                return ret2.replace("{{args}}", args).replace(", ", comma);
              }
              function generateArgumentSwitchCase() {
                var ret2 = "";
                for (var i = 0; i < argumentOrder.length; ++i) {
                  ret2 += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
                }
                ret2 += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
                return ret2;
              }
              var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
              var body = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
              body = body.replace("Parameters", parameterDeclaration(newParameterCount));
              return new Function(
                "Promise",
                "fn",
                "receiver",
                "withAppended",
                "maybeWrapAsError",
                "nodebackForPromise",
                "tryCatch",
                "errorObj",
                "notEnumerableProp",
                "INTERNAL",
                body
              )(
                Promise2,
                fn,
                receiver2,
                withAppended2,
                maybeWrapAsError2,
                nodebackForPromise,
                util.tryCatch,
                util.errorObj,
                util.notEnumerableProp,
                INTERNAL
              );
            };
          }
          function makeNodePromisifiedClosure(callback, receiver2, _, fn, __, multiArgs) {
            var defaultThis = function() {
              return this;
            }();
            var method = callback;
            if (typeof method === "string") {
              callback = fn;
            }
            function promisified() {
              var _receiver = receiver2;
              if (receiver2 === THIS)
                _receiver = this;
              var promise = new Promise2(INTERNAL);
              promise._captureStackTrace();
              var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
              var fn2 = nodebackForPromise(promise, multiArgs);
              try {
                cb.apply(_receiver, withAppended2(arguments, fn2));
              } catch (e) {
                promise._rejectCallback(maybeWrapAsError2(e), true, true);
              }
              if (!promise._isFateSealed())
                promise._setAsyncGuaranteed();
              return promise;
            }
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            return promisified;
          }
          var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
          function promisifyAll(obj2, suffix, filter, promisifier, multiArgs) {
            var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
            var methods = promisifiableMethods(obj2, suffix, suffixRegexp, filter);
            for (var i = 0, len = methods.length; i < len; i += 2) {
              var key = methods[i];
              var fn = methods[i + 1];
              var promisifiedKey = key + suffix;
              if (promisifier === makeNodePromisified) {
                obj2[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
              } else {
                var promisified = promisifier(fn, function() {
                  return makeNodePromisified(
                    key,
                    THIS,
                    key,
                    fn,
                    suffix,
                    multiArgs
                  );
                });
                util.notEnumerableProp(promisified, "__isPromisified__", true);
                obj2[promisifiedKey] = promisified;
              }
            }
            util.toFastProperties(obj2);
            return obj2;
          }
          function promisify(callback, receiver2, multiArgs) {
            return makeNodePromisified(
              callback,
              receiver2,
              void 0,
              callback,
              null,
              multiArgs
            );
          }
          Promise2.promisify = function(fn, options) {
            if (typeof fn !== "function") {
              throw new TypeError2("expecting a function but got " + util.classString(fn));
            }
            if (isPromisified(fn)) {
              return fn;
            }
            options = Object(options);
            var receiver2 = options.context === void 0 ? THIS : options.context;
            var multiArgs = !!options.multiArgs;
            var ret2 = promisify(fn, receiver2, multiArgs);
            util.copyDescriptors(fn, ret2, propsFilter);
            return ret2;
          };
          Promise2.promisifyAll = function(target, options) {
            if (typeof target !== "function" && typeof target !== "object") {
              throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
            }
            options = Object(options);
            var multiArgs = !!options.multiArgs;
            var suffix = options.suffix;
            if (typeof suffix !== "string")
              suffix = defaultSuffix;
            var filter = options.filter;
            if (typeof filter !== "function")
              filter = defaultFilter;
            var promisifier = options.promisifier;
            if (typeof promisifier !== "function")
              promisifier = makeNodePromisified;
            if (!util.isIdentifier(suffix)) {
              throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
            }
            var keys = util.inheritedDataKeys(target);
            for (var i = 0; i < keys.length; ++i) {
              var value = target[keys[i]];
              if (keys[i] !== "constructor" && util.isClass(value)) {
                promisifyAll(
                  value.prototype,
                  suffix,
                  filter,
                  promisifier,
                  multiArgs
                );
                promisifyAll(value, suffix, filter, promisifier, multiArgs);
              }
            }
            return promisifyAll(target, suffix, filter, promisifier, multiArgs);
          };
        };
      }, { "./errors": 12, "./nodeback": 20, "./util": 36 }], 25: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util");
          var isObject2 = util.isObject;
          var es52 = _dereq_2("./es5");
          var Es6Map;
          if (typeof Map === "function")
            Es6Map = Map;
          var mapToEntries = function() {
            var index = 0;
            var size = 0;
            function extractEntry(value, key) {
              this[index] = value;
              this[index + size] = key;
              index++;
            }
            return function mapToEntries2(map) {
              size = map.size;
              index = 0;
              var ret2 = new Array(map.size * 2);
              map.forEach(extractEntry, ret2);
              return ret2;
            };
          }();
          var entriesToMap = function(entries) {
            var ret2 = new Es6Map();
            var length = entries.length / 2 | 0;
            for (var i = 0; i < length; ++i) {
              var key = entries[length + i];
              var value = entries[i];
              ret2.set(key, value);
            }
            return ret2;
          };
          function PropertiesPromiseArray(obj2) {
            var isMap = false;
            var entries;
            if (Es6Map !== void 0 && obj2 instanceof Es6Map) {
              entries = mapToEntries(obj2);
              isMap = true;
            } else {
              var keys = es52.keys(obj2);
              var len = keys.length;
              entries = new Array(len * 2);
              for (var i = 0; i < len; ++i) {
                var key = keys[i];
                entries[i] = obj2[key];
                entries[i + len] = key;
              }
            }
            this.constructor$(entries);
            this._isMap = isMap;
            this._init$(void 0, isMap ? -6 : -3);
          }
          util.inherits(PropertiesPromiseArray, PromiseArray);
          PropertiesPromiseArray.prototype._init = function() {
          };
          PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
            this._values[index] = value;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              var val;
              if (this._isMap) {
                val = entriesToMap(this._values);
              } else {
                val = {};
                var keyOffset = this.length();
                for (var i = 0, len = this.length(); i < len; ++i) {
                  val[this._values[i + keyOffset]] = this._values[i];
                }
              }
              this._resolve(val);
              return true;
            }
            return false;
          };
          PropertiesPromiseArray.prototype.shouldCopyValues = function() {
            return false;
          };
          PropertiesPromiseArray.prototype.getActualLength = function(len) {
            return len >> 1;
          };
          function props(promises) {
            var ret2;
            var castValue = tryConvertToPromise(promises);
            if (!isObject2(castValue)) {
              return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
            } else if (castValue instanceof Promise2) {
              ret2 = castValue._then(
                Promise2.props,
                void 0,
                void 0,
                void 0,
                void 0
              );
            } else {
              ret2 = new PropertiesPromiseArray(castValue).promise();
            }
            if (castValue instanceof Promise2) {
              ret2._propagateFrom(castValue, 2);
            }
            return ret2;
          }
          Promise2.prototype.props = function() {
            return props(this);
          };
          Promise2.props = function(promises) {
            return props(promises);
          };
        };
      }, { "./es5": 13, "./util": 36 }], 26: [function(_dereq_2, module2, exports2) {
        "use strict";
        function arrayMove(src, srcIndex, dst, dstIndex, len) {
          for (var j = 0; j < len; ++j) {
            dst[j + dstIndex] = src[j + srcIndex];
            src[j + srcIndex] = void 0;
          }
        }
        function Queue(capacity) {
          this._capacity = capacity;
          this._length = 0;
          this._front = 0;
        }
        Queue.prototype._willBeOverCapacity = function(size) {
          return this._capacity < size;
        };
        Queue.prototype._pushOne = function(arg) {
          var length = this.length();
          this._checkCapacity(length + 1);
          var i = this._front + length & this._capacity - 1;
          this[i] = arg;
          this._length = length + 1;
        };
        Queue.prototype.push = function(fn, receiver2, arg) {
          var length = this.length() + 3;
          if (this._willBeOverCapacity(length)) {
            this._pushOne(fn);
            this._pushOne(receiver2);
            this._pushOne(arg);
            return;
          }
          var j = this._front + length - 3;
          this._checkCapacity(length);
          var wrapMask = this._capacity - 1;
          this[j + 0 & wrapMask] = fn;
          this[j + 1 & wrapMask] = receiver2;
          this[j + 2 & wrapMask] = arg;
          this._length = length;
        };
        Queue.prototype.shift = function() {
          var front = this._front, ret2 = this[front];
          this[front] = void 0;
          this._front = front + 1 & this._capacity - 1;
          this._length--;
          return ret2;
        };
        Queue.prototype.length = function() {
          return this._length;
        };
        Queue.prototype._checkCapacity = function(size) {
          if (this._capacity < size) {
            this._resizeTo(this._capacity << 1);
          }
        };
        Queue.prototype._resizeTo = function(capacity) {
          var oldCapacity = this._capacity;
          this._capacity = capacity;
          var front = this._front;
          var length = this._length;
          var moveItemsCount = front + length & oldCapacity - 1;
          arrayMove(this, 0, this, oldCapacity, moveItemsCount);
        };
        module2.exports = Queue;
      }, {}], 27: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
          var util = _dereq_2("./util");
          var raceLater = function(promise) {
            return promise.then(function(array) {
              return race(array, promise);
            });
          };
          function race(promises, parent) {
            var maybePromise = tryConvertToPromise(promises);
            if (maybePromise instanceof Promise2) {
              return raceLater(maybePromise);
            } else {
              promises = util.asArray(promises);
              if (promises === null)
                return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
            }
            var ret2 = new Promise2(INTERNAL);
            if (parent !== void 0) {
              ret2._propagateFrom(parent, 3);
            }
            var fulfill = ret2._fulfill;
            var reject = ret2._reject;
            for (var i = 0, len = promises.length; i < len; ++i) {
              var val = promises[i];
              if (val === void 0 && !(i in promises)) {
                continue;
              }
              Promise2.cast(val)._then(fulfill, reject, void 0, ret2, null);
            }
            return ret2;
          }
          Promise2.race = function(promises) {
            return race(promises, void 0);
          };
          Promise2.prototype.race = function() {
            return race(this, void 0);
          };
        };
      }, { "./util": 36 }], 28: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
          var util = _dereq_2("./util");
          var tryCatch2 = util.tryCatch;
          function ReductionPromiseArray(promises, fn, initialValue, _each) {
            this.constructor$(promises);
            var context = Promise2._getContext();
            this._fn = util.contextBind(context, fn);
            if (initialValue !== void 0) {
              initialValue = Promise2.resolve(initialValue);
              initialValue._attachCancellationCallback(this);
            }
            this._initialValue = initialValue;
            this._currentCancellable = null;
            if (_each === INTERNAL) {
              this._eachValues = Array(this._length);
            } else if (_each === 0) {
              this._eachValues = null;
            } else {
              this._eachValues = void 0;
            }
            this._promise._captureStackTrace();
            this._init$(void 0, -5);
          }
          util.inherits(ReductionPromiseArray, PromiseArray);
          ReductionPromiseArray.prototype._gotAccum = function(accum) {
            if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL) {
              this._eachValues.push(accum);
            }
          };
          ReductionPromiseArray.prototype._eachComplete = function(value) {
            if (this._eachValues !== null) {
              this._eachValues.push(value);
            }
            return this._eachValues;
          };
          ReductionPromiseArray.prototype._init = function() {
          };
          ReductionPromiseArray.prototype._resolveEmptyArray = function() {
            this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
          };
          ReductionPromiseArray.prototype.shouldCopyValues = function() {
            return false;
          };
          ReductionPromiseArray.prototype._resolve = function(value) {
            this._promise._resolveCallback(value);
            this._values = null;
          };
          ReductionPromiseArray.prototype._resultCancelled = function(sender) {
            if (sender === this._initialValue)
              return this._cancel();
            if (this._isResolved())
              return;
            this._resultCancelled$();
            if (this._currentCancellable instanceof Promise2) {
              this._currentCancellable.cancel();
            }
            if (this._initialValue instanceof Promise2) {
              this._initialValue.cancel();
            }
          };
          ReductionPromiseArray.prototype._iterate = function(values) {
            this._values = values;
            var value;
            var i;
            var length = values.length;
            if (this._initialValue !== void 0) {
              value = this._initialValue;
              i = 0;
            } else {
              value = Promise2.resolve(values[0]);
              i = 1;
            }
            this._currentCancellable = value;
            for (var j = i; j < length; ++j) {
              var maybePromise = values[j];
              if (maybePromise instanceof Promise2) {
                maybePromise.suppressUnhandledRejections();
              }
            }
            if (!value.isRejected()) {
              for (; i < length; ++i) {
                var ctx = {
                  accum: null,
                  value: values[i],
                  index: i,
                  length,
                  array: this
                };
                value = value._then(gotAccum, void 0, void 0, ctx, void 0);
                if ((i & 127) === 0) {
                  value._setNoAsyncGuarantee();
                }
              }
            }
            if (this._eachValues !== void 0) {
              value = value._then(this._eachComplete, void 0, void 0, this, void 0);
            }
            value._then(completed, completed, void 0, value, this);
          };
          Promise2.prototype.reduce = function(fn, initialValue) {
            return reduce(this, fn, initialValue, null);
          };
          Promise2.reduce = function(promises, fn, initialValue, _each) {
            return reduce(promises, fn, initialValue, _each);
          };
          function completed(valueOrReason, array) {
            if (this.isFulfilled()) {
              array._resolve(valueOrReason);
            } else {
              array._reject(valueOrReason);
            }
          }
          function reduce(promises, fn, initialValue, _each) {
            if (typeof fn !== "function") {
              return apiRejection("expecting a function but got " + util.classString(fn));
            }
            var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
            return array.promise();
          }
          function gotAccum(accum) {
            this.accum = accum;
            this.array._gotAccum(accum);
            var value = tryConvertToPromise(this.value, this.array._promise);
            if (value instanceof Promise2) {
              this.array._currentCancellable = value;
              return value._then(gotValue, void 0, void 0, this, void 0);
            } else {
              return gotValue.call(this, value);
            }
          }
          function gotValue(value) {
            var array = this.array;
            var promise = array._promise;
            var fn = tryCatch2(array._fn);
            promise._pushContext();
            var ret2;
            if (array._eachValues !== void 0) {
              ret2 = fn.call(promise._boundValue(), value, this.index, this.length);
            } else {
              ret2 = fn.call(
                promise._boundValue(),
                this.accum,
                value,
                this.index,
                this.length
              );
            }
            if (ret2 instanceof Promise2) {
              array._currentCancellable = ret2;
            }
            var promiseCreated = promise._popContext();
            debug.checkForgottenReturns(
              ret2,
              promiseCreated,
              array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
              promise
            );
            return ret2;
          }
        };
      }, { "./util": 36 }], 29: [function(_dereq_2, module2, exports2) {
        "use strict";
        var util = _dereq_2("./util");
        var schedule;
        var noAsyncScheduler = function() {
          throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
        };
        var NativePromise = util.getNativePromise();
        if (util.isNode && typeof MutationObserver === "undefined") {
          var GlobalSetImmediate = global.setImmediate;
          var ProcessNextTick = process.nextTick;
          schedule = util.isRecentNode ? function(fn) {
            GlobalSetImmediate.call(global, fn);
          } : function(fn) {
            ProcessNextTick.call(process, fn);
          };
        } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
          var nativePromise = NativePromise.resolve();
          schedule = function(fn) {
            nativePromise.then(fn);
          };
        } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova)) && "classList" in document.documentElement) {
          schedule = function() {
            var div = document.createElement("div");
            var opts = { attributes: true };
            var toggleScheduled = false;
            var div2 = document.createElement("div");
            var o2 = new MutationObserver(function() {
              div.classList.toggle("foo");
              toggleScheduled = false;
            });
            o2.observe(div2, opts);
            var scheduleToggle = function() {
              if (toggleScheduled)
                return;
              toggleScheduled = true;
              div2.classList.toggle("foo");
            };
            return function schedule2(fn) {
              var o = new MutationObserver(function() {
                o.disconnect();
                fn();
              });
              o.observe(div, opts);
              scheduleToggle();
            };
          }();
        } else if (typeof setImmediate !== "undefined") {
          schedule = function(fn) {
            setImmediate(fn);
          };
        } else if (typeof setTimeout !== "undefined") {
          schedule = function(fn) {
            setTimeout(fn, 0);
          };
        } else {
          schedule = noAsyncScheduler;
        }
        module2.exports = schedule;
      }, { "./util": 36 }], 30: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, debug) {
          var PromiseInspection = Promise2.PromiseInspection;
          var util = _dereq_2("./util");
          function SettledPromiseArray(values) {
            this.constructor$(values);
          }
          util.inherits(SettledPromiseArray, PromiseArray);
          SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
            this._values[index] = inspection;
            var totalResolved = ++this._totalResolved;
            if (totalResolved >= this._length) {
              this._resolve(this._values);
              return true;
            }
            return false;
          };
          SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var ret2 = new PromiseInspection();
            ret2._bitField = 33554432;
            ret2._settledValueField = value;
            return this._promiseResolved(index, ret2);
          };
          SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
            var ret2 = new PromiseInspection();
            ret2._bitField = 16777216;
            ret2._settledValueField = reason;
            return this._promiseResolved(index, ret2);
          };
          Promise2.settle = function(promises) {
            debug.deprecated(".settle()", ".reflect()");
            return new SettledPromiseArray(promises).promise();
          };
          Promise2.allSettled = function(promises) {
            return new SettledPromiseArray(promises).promise();
          };
          Promise2.prototype.settle = function() {
            return Promise2.settle(this);
          };
        };
      }, { "./util": 36 }], 31: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, PromiseArray, apiRejection) {
          var util = _dereq_2("./util");
          var RangeError2 = _dereq_2("./errors").RangeError;
          var AggregateError = _dereq_2("./errors").AggregateError;
          var isArray = util.isArray;
          var CANCELLATION = {};
          function SomePromiseArray(values) {
            this.constructor$(values);
            this._howMany = 0;
            this._unwrap = false;
            this._initialized = false;
          }
          util.inherits(SomePromiseArray, PromiseArray);
          SomePromiseArray.prototype._init = function() {
            if (!this._initialized) {
              return;
            }
            if (this._howMany === 0) {
              this._resolve([]);
              return;
            }
            this._init$(void 0, -5);
            var isArrayResolved = isArray(this._values);
            if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
              this._reject(this._getRangeError(this.length()));
            }
          };
          SomePromiseArray.prototype.init = function() {
            this._initialized = true;
            this._init();
          };
          SomePromiseArray.prototype.setUnwrap = function() {
            this._unwrap = true;
          };
          SomePromiseArray.prototype.howMany = function() {
            return this._howMany;
          };
          SomePromiseArray.prototype.setHowMany = function(count) {
            this._howMany = count;
          };
          SomePromiseArray.prototype._promiseFulfilled = function(value) {
            this._addFulfilled(value);
            if (this._fulfilled() === this.howMany()) {
              this._values.length = this.howMany();
              if (this.howMany() === 1 && this._unwrap) {
                this._resolve(this._values[0]);
              } else {
                this._resolve(this._values);
              }
              return true;
            }
            return false;
          };
          SomePromiseArray.prototype._promiseRejected = function(reason) {
            this._addRejected(reason);
            return this._checkOutcome();
          };
          SomePromiseArray.prototype._promiseCancelled = function() {
            if (this._values instanceof Promise2 || this._values == null) {
              return this._cancel();
            }
            this._addRejected(CANCELLATION);
            return this._checkOutcome();
          };
          SomePromiseArray.prototype._checkOutcome = function() {
            if (this.howMany() > this._canPossiblyFulfill()) {
              var e = new AggregateError();
              for (var i = this.length(); i < this._values.length; ++i) {
                if (this._values[i] !== CANCELLATION) {
                  e.push(this._values[i]);
                }
              }
              if (e.length > 0) {
                this._reject(e);
              } else {
                this._cancel();
              }
              return true;
            }
            return false;
          };
          SomePromiseArray.prototype._fulfilled = function() {
            return this._totalResolved;
          };
          SomePromiseArray.prototype._rejected = function() {
            return this._values.length - this.length();
          };
          SomePromiseArray.prototype._addRejected = function(reason) {
            this._values.push(reason);
          };
          SomePromiseArray.prototype._addFulfilled = function(value) {
            this._values[this._totalResolved++] = value;
          };
          SomePromiseArray.prototype._canPossiblyFulfill = function() {
            return this.length() - this._rejected();
          };
          SomePromiseArray.prototype._getRangeError = function(count) {
            var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
            return new RangeError2(message);
          };
          SomePromiseArray.prototype._resolveEmptyArray = function() {
            this._reject(this._getRangeError(0));
          };
          function some(promises, howMany) {
            if ((howMany | 0) !== howMany || howMany < 0) {
              return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
            }
            var ret2 = new SomePromiseArray(promises);
            var promise = ret2.promise();
            ret2.setHowMany(howMany);
            ret2.init();
            return promise;
          }
          Promise2.some = function(promises, howMany) {
            return some(promises, howMany);
          };
          Promise2.prototype.some = function(howMany) {
            return some(this, howMany);
          };
          Promise2._SomePromiseArray = SomePromiseArray;
        };
      }, { "./errors": 12, "./util": 36 }], 32: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2) {
          function PromiseInspection(promise) {
            if (promise !== void 0) {
              promise = promise._target();
              this._bitField = promise._bitField;
              this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0;
            } else {
              this._bitField = 0;
              this._settledValueField = void 0;
            }
          }
          PromiseInspection.prototype._settledValue = function() {
            return this._settledValueField;
          };
          var value = PromiseInspection.prototype.value = function() {
            if (!this.isFulfilled()) {
              throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
            }
            return this._settledValue();
          };
          var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
            if (!this.isRejected()) {
              throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
            }
            return this._settledValue();
          };
          var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
            return (this._bitField & 33554432) !== 0;
          };
          var isRejected = PromiseInspection.prototype.isRejected = function() {
            return (this._bitField & 16777216) !== 0;
          };
          var isPending = PromiseInspection.prototype.isPending = function() {
            return (this._bitField & 50397184) === 0;
          };
          var isResolved = PromiseInspection.prototype.isResolved = function() {
            return (this._bitField & 50331648) !== 0;
          };
          PromiseInspection.prototype.isCancelled = function() {
            return (this._bitField & 8454144) !== 0;
          };
          Promise2.prototype.__isCancelled = function() {
            return (this._bitField & 65536) === 65536;
          };
          Promise2.prototype._isCancelled = function() {
            return this._target().__isCancelled();
          };
          Promise2.prototype.isCancelled = function() {
            return (this._target()._bitField & 8454144) !== 0;
          };
          Promise2.prototype.isPending = function() {
            return isPending.call(this._target());
          };
          Promise2.prototype.isRejected = function() {
            return isRejected.call(this._target());
          };
          Promise2.prototype.isFulfilled = function() {
            return isFulfilled.call(this._target());
          };
          Promise2.prototype.isResolved = function() {
            return isResolved.call(this._target());
          };
          Promise2.prototype.value = function() {
            return value.call(this._target());
          };
          Promise2.prototype.reason = function() {
            var target = this._target();
            target._unsetRejectionIsUnhandled();
            return reason.call(target);
          };
          Promise2.prototype._value = function() {
            return this._settledValue();
          };
          Promise2.prototype._reason = function() {
            this._unsetRejectionIsUnhandled();
            return this._settledValue();
          };
          Promise2.PromiseInspection = PromiseInspection;
        };
      }, {}], 33: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL) {
          var util = _dereq_2("./util");
          var errorObj2 = util.errorObj;
          var isObject2 = util.isObject;
          function tryConvertToPromise(obj2, context) {
            if (isObject2(obj2)) {
              if (obj2 instanceof Promise2)
                return obj2;
              var then = getThen(obj2);
              if (then === errorObj2) {
                if (context)
                  context._pushContext();
                var ret2 = Promise2.reject(then.e);
                if (context)
                  context._popContext();
                return ret2;
              } else if (typeof then === "function") {
                if (isAnyBluebirdPromise(obj2)) {
                  var ret2 = new Promise2(INTERNAL);
                  obj2._then(
                    ret2._fulfill,
                    ret2._reject,
                    void 0,
                    ret2,
                    null
                  );
                  return ret2;
                }
                return doThenable(obj2, then, context);
              }
            }
            return obj2;
          }
          function doGetThen(obj2) {
            return obj2.then;
          }
          function getThen(obj2) {
            try {
              return doGetThen(obj2);
            } catch (e) {
              errorObj2.e = e;
              return errorObj2;
            }
          }
          var hasProp = {}.hasOwnProperty;
          function isAnyBluebirdPromise(obj2) {
            try {
              return hasProp.call(obj2, "_promise0");
            } catch (e) {
              return false;
            }
          }
          function doThenable(x, then, context) {
            var promise = new Promise2(INTERNAL);
            var ret2 = promise;
            if (context)
              context._pushContext();
            promise._captureStackTrace();
            if (context)
              context._popContext();
            var synchronous = true;
            var result = util.tryCatch(then).call(x, resolve, reject);
            synchronous = false;
            if (promise && result === errorObj2) {
              promise._rejectCallback(result.e, true, true);
              promise = null;
            }
            function resolve(value) {
              if (!promise)
                return;
              promise._resolveCallback(value);
              promise = null;
            }
            function reject(reason) {
              if (!promise)
                return;
              promise._rejectCallback(reason, synchronous, true);
              promise = null;
            }
            return ret2;
          }
          return tryConvertToPromise;
        };
      }, { "./util": 36 }], 34: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, INTERNAL, debug) {
          var util = _dereq_2("./util");
          var TimeoutError = Promise2.TimeoutError;
          function HandleWrapper(handle) {
            this.handle = handle;
          }
          HandleWrapper.prototype._resultCancelled = function() {
            clearTimeout(this.handle);
          };
          var afterValue = function(value) {
            return delay(+this).thenReturn(value);
          };
          var delay = Promise2.delay = function(ms, value) {
            var ret2;
            var handle;
            if (value !== void 0) {
              ret2 = Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
              if (debug.cancellation() && value instanceof Promise2) {
                ret2._setOnCancel(value);
              }
            } else {
              ret2 = new Promise2(INTERNAL);
              handle = setTimeout(function() {
                ret2._fulfill();
              }, +ms);
              if (debug.cancellation()) {
                ret2._setOnCancel(new HandleWrapper(handle));
              }
              ret2._captureStackTrace();
            }
            ret2._setAsyncGuaranteed();
            return ret2;
          };
          Promise2.prototype.delay = function(ms) {
            return delay(ms, this);
          };
          var afterTimeout = function(promise, message, parent) {
            var err;
            if (typeof message !== "string") {
              if (message instanceof Error) {
                err = message;
              } else {
                err = new TimeoutError("operation timed out");
              }
            } else {
              err = new TimeoutError(message);
            }
            util.markAsOriginatingFromRejection(err);
            promise._attachExtraTrace(err);
            promise._reject(err);
            if (parent != null) {
              parent.cancel();
            }
          };
          function successClear(value) {
            clearTimeout(this.handle);
            return value;
          }
          function failureClear(reason) {
            clearTimeout(this.handle);
            throw reason;
          }
          Promise2.prototype.timeout = function(ms, message) {
            ms = +ms;
            var ret2, parent;
            var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
              if (ret2.isPending()) {
                afterTimeout(ret2, message, parent);
              }
            }, ms));
            if (debug.cancellation()) {
              parent = this.then();
              ret2 = parent._then(
                successClear,
                failureClear,
                void 0,
                handleWrapper,
                void 0
              );
              ret2._setOnCancel(handleWrapper);
            } else {
              ret2 = this._then(
                successClear,
                failureClear,
                void 0,
                handleWrapper,
                void 0
              );
            }
            return ret2;
          };
        };
      }, { "./util": 36 }], 35: [function(_dereq_2, module2, exports2) {
        "use strict";
        module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
          var util = _dereq_2("./util");
          var TypeError2 = _dereq_2("./errors").TypeError;
          var inherits2 = _dereq_2("./util").inherits;
          var errorObj2 = util.errorObj;
          var tryCatch2 = util.tryCatch;
          var NULL = {};
          function thrower2(e) {
            setTimeout(function() {
              throw e;
            }, 0);
          }
          function castPreservingDisposable(thenable) {
            var maybePromise = tryConvertToPromise(thenable);
            if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
              maybePromise._setDisposable(thenable._getDisposer());
            }
            return maybePromise;
          }
          function dispose(resources, inspection) {
            var i = 0;
            var len = resources.length;
            var ret2 = new Promise2(INTERNAL);
            function iterator() {
              if (i >= len)
                return ret2._fulfill();
              var maybePromise = castPreservingDisposable(resources[i++]);
              if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
                try {
                  maybePromise = tryConvertToPromise(
                    maybePromise._getDisposer().tryDispose(inspection),
                    resources.promise
                  );
                } catch (e) {
                  return thrower2(e);
                }
                if (maybePromise instanceof Promise2) {
                  return maybePromise._then(
                    iterator,
                    thrower2,
                    null,
                    null,
                    null
                  );
                }
              }
              iterator();
            }
            iterator();
            return ret2;
          }
          function Disposer(data, promise, context) {
            this._data = data;
            this._promise = promise;
            this._context = context;
          }
          Disposer.prototype.data = function() {
            return this._data;
          };
          Disposer.prototype.promise = function() {
            return this._promise;
          };
          Disposer.prototype.resource = function() {
            if (this.promise().isFulfilled()) {
              return this.promise().value();
            }
            return NULL;
          };
          Disposer.prototype.tryDispose = function(inspection) {
            var resource = this.resource();
            var context = this._context;
            if (context !== void 0)
              context._pushContext();
            var ret2 = resource !== NULL ? this.doDispose(resource, inspection) : null;
            if (context !== void 0)
              context._popContext();
            this._promise._unsetDisposable();
            this._data = null;
            return ret2;
          };
          Disposer.isDisposer = function(d) {
            return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
          };
          function FunctionDisposer(fn, promise, context) {
            this.constructor$(fn, promise, context);
          }
          inherits2(FunctionDisposer, Disposer);
          FunctionDisposer.prototype.doDispose = function(resource, inspection) {
            var fn = this.data();
            return fn.call(resource, resource, inspection);
          };
          function maybeUnwrapDisposer(value) {
            if (Disposer.isDisposer(value)) {
              this.resources[this.index]._setDisposable(value);
              return value.promise();
            }
            return value;
          }
          function ResourceList(length) {
            this.length = length;
            this.promise = null;
            this[length - 1] = null;
          }
          ResourceList.prototype._resultCancelled = function() {
            var len = this.length;
            for (var i = 0; i < len; ++i) {
              var item = this[i];
              if (item instanceof Promise2) {
                item.cancel();
              }
            }
          };
          Promise2.using = function() {
            var len = arguments.length;
            if (len < 2)
              return apiRejection(
                "you must pass at least 2 arguments to Promise.using"
              );
            var fn = arguments[len - 1];
            if (typeof fn !== "function") {
              return apiRejection("expecting a function but got " + util.classString(fn));
            }
            var input;
            var spreadArgs = true;
            if (len === 2 && Array.isArray(arguments[0])) {
              input = arguments[0];
              len = input.length;
              spreadArgs = false;
            } else {
              input = arguments;
              len--;
            }
            var resources = new ResourceList(len);
            for (var i = 0; i < len; ++i) {
              var resource = input[i];
              if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
              } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise2) {
                  resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                    resources,
                    index: i
                  }, void 0);
                }
              }
              resources[i] = resource;
            }
            var reflectedResources = new Array(resources.length);
            for (var i = 0; i < reflectedResources.length; ++i) {
              reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
            }
            var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
              for (var i2 = 0; i2 < inspections.length; ++i2) {
                var inspection = inspections[i2];
                if (inspection.isRejected()) {
                  errorObj2.e = inspection.error();
                  return errorObj2;
                } else if (!inspection.isFulfilled()) {
                  resultPromise.cancel();
                  return;
                }
                inspections[i2] = inspection.value();
              }
              promise._pushContext();
              fn = tryCatch2(fn);
              var ret2 = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections);
              var promiseCreated = promise._popContext();
              debug.checkForgottenReturns(
                ret2,
                promiseCreated,
                "Promise.using",
                promise
              );
              return ret2;
            });
            var promise = resultPromise.lastly(function() {
              var inspection = new Promise2.PromiseInspection(resultPromise);
              return dispose(resources, inspection);
            });
            resources.promise = promise;
            promise._setOnCancel(resources);
            return promise;
          };
          Promise2.prototype._setDisposable = function(disposer) {
            this._bitField = this._bitField | 131072;
            this._disposer = disposer;
          };
          Promise2.prototype._isDisposable = function() {
            return (this._bitField & 131072) > 0;
          };
          Promise2.prototype._getDisposer = function() {
            return this._disposer;
          };
          Promise2.prototype._unsetDisposable = function() {
            this._bitField = this._bitField & ~131072;
            this._disposer = void 0;
          };
          Promise2.prototype.disposer = function(fn) {
            if (typeof fn === "function") {
              return new FunctionDisposer(fn, this, createContext());
            }
            throw new TypeError2();
          };
        };
      }, { "./errors": 12, "./util": 36 }], 36: [function(_dereq_, module, exports) {
        "use strict";
        var es5 = _dereq_("./es5");
        var canEvaluate = typeof navigator == "undefined";
        var errorObj = { e: {} };
        var tryCatchTarget;
        var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : this !== void 0 ? this : null;
        function tryCatcher() {
          try {
            var target = tryCatchTarget;
            tryCatchTarget = null;
            return target.apply(this, arguments);
          } catch (e) {
            errorObj.e = e;
            return errorObj;
          }
        }
        function tryCatch(fn) {
          tryCatchTarget = fn;
          return tryCatcher;
        }
        var inherits = function(Child, Parent) {
          var hasProp = {}.hasOwnProperty;
          function T() {
            this.constructor = Child;
            this.constructor$ = Parent;
            for (var propertyName in Parent.prototype) {
              if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                this[propertyName + "$"] = Parent.prototype[propertyName];
              }
            }
          }
          T.prototype = Parent.prototype;
          Child.prototype = new T();
          return Child.prototype;
        };
        function isPrimitive(val) {
          return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
        }
        function isObject(value) {
          return typeof value === "function" || typeof value === "object" && value !== null;
        }
        function maybeWrapAsError(maybeError) {
          if (!isPrimitive(maybeError))
            return maybeError;
          return new Error(safeToString(maybeError));
        }
        function withAppended(target, appendee) {
          var len = target.length;
          var ret2 = new Array(len + 1);
          var i;
          for (i = 0; i < len; ++i) {
            ret2[i] = target[i];
          }
          ret2[i] = appendee;
          return ret2;
        }
        function getDataPropertyOrDefault(obj2, key, defaultValue) {
          if (es5.isES5) {
            var desc = Object.getOwnPropertyDescriptor(obj2, key);
            if (desc != null) {
              return desc.get == null && desc.set == null ? desc.value : defaultValue;
            }
          } else {
            return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
          }
        }
        function notEnumerableProp(obj2, name, value) {
          if (isPrimitive(obj2))
            return obj2;
          var descriptor = {
            value,
            configurable: true,
            enumerable: false,
            writable: true
          };
          es5.defineProperty(obj2, name, descriptor);
          return obj2;
        }
        function thrower(r) {
          throw r;
        }
        var inheritedDataKeys = function() {
          var excludedPrototypes = [
            Array.prototype,
            Object.prototype,
            Function.prototype
          ];
          var isExcludedProto = function(val) {
            for (var i = 0; i < excludedPrototypes.length; ++i) {
              if (excludedPrototypes[i] === val) {
                return true;
              }
            }
            return false;
          };
          if (es5.isES5) {
            var getKeys = Object.getOwnPropertyNames;
            return function(obj2) {
              var ret2 = [];
              var visitedKeys = /* @__PURE__ */ Object.create(null);
              while (obj2 != null && !isExcludedProto(obj2)) {
                var keys;
                try {
                  keys = getKeys(obj2);
                } catch (e) {
                  return ret2;
                }
                for (var i = 0; i < keys.length; ++i) {
                  var key = keys[i];
                  if (visitedKeys[key])
                    continue;
                  visitedKeys[key] = true;
                  var desc = Object.getOwnPropertyDescriptor(obj2, key);
                  if (desc != null && desc.get == null && desc.set == null) {
                    ret2.push(key);
                  }
                }
                obj2 = es5.getPrototypeOf(obj2);
              }
              return ret2;
            };
          } else {
            var hasProp = {}.hasOwnProperty;
            return function(obj2) {
              if (isExcludedProto(obj2))
                return [];
              var ret2 = [];
              enumeration:
                for (var key in obj2) {
                  if (hasProp.call(obj2, key)) {
                    ret2.push(key);
                  } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                      if (hasProp.call(excludedPrototypes[i], key)) {
                        continue enumeration;
                      }
                    }
                    ret2.push(key);
                  }
                }
              return ret2;
            };
          }
        }();
        var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
        function isClass(fn) {
          try {
            if (typeof fn === "function") {
              var keys = es5.names(fn.prototype);
              var hasMethods = es5.isES5 && keys.length > 1;
              var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
              var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
              if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
                return true;
              }
            }
            return false;
          } catch (e) {
            return false;
          }
        }
        function toFastProperties(obj) {
          function FakeConstructor() {
          }
          FakeConstructor.prototype = obj;
          var receiver = new FakeConstructor();
          function ic() {
            return typeof receiver.foo;
          }
          ic();
          ic();
          return obj;
          eval(obj);
        }
        var rident = /^[a-z$_][a-z$_0-9]*$/i;
        function isIdentifier(str) {
          return rident.test(str);
        }
        function filledRange(count, prefix, suffix) {
          var ret2 = new Array(count);
          for (var i = 0; i < count; ++i) {
            ret2[i] = prefix + i + suffix;
          }
          return ret2;
        }
        function safeToString(obj2) {
          try {
            return obj2 + "";
          } catch (e) {
            return "[no string representation]";
          }
        }
        function isError(obj2) {
          return obj2 instanceof Error || obj2 !== null && typeof obj2 === "object" && typeof obj2.message === "string" && typeof obj2.name === "string";
        }
        function markAsOriginatingFromRejection(e) {
          try {
            notEnumerableProp(e, "isOperational", true);
          } catch (ignore) {
          }
        }
        function originatesFromRejection(e) {
          if (e == null)
            return false;
          return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
        }
        function canAttachTrace(obj2) {
          return isError(obj2) && es5.propertyIsWritable(obj2, "stack");
        }
        var ensureErrorObject = function() {
          if (!("stack" in new Error())) {
            return function(value) {
              if (canAttachTrace(value))
                return value;
              try {
                throw new Error(safeToString(value));
              } catch (err) {
                return err;
              }
            };
          } else {
            return function(value) {
              if (canAttachTrace(value))
                return value;
              return new Error(safeToString(value));
            };
          }
        }();
        function classString(obj2) {
          return {}.toString.call(obj2);
        }
        function copyDescriptors(from, to, filter) {
          var keys = es5.names(from);
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (filter(key)) {
              try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
              } catch (ignore) {
              }
            }
          }
        }
        var asArray = function(v) {
          if (es5.isArray(v)) {
            return v;
          }
          return null;
        };
        if (typeof Symbol !== "undefined" && Symbol.iterator) {
          var ArrayFrom = typeof Array.from === "function" ? function(v) {
            return Array.from(v);
          } : function(v) {
            var ret2 = [];
            var it = v[Symbol.iterator]();
            var itResult;
            while (!(itResult = it.next()).done) {
              ret2.push(itResult.value);
            }
            return ret2;
          };
          asArray = function(v) {
            if (es5.isArray(v)) {
              return v;
            } else if (v != null && typeof v[Symbol.iterator] === "function") {
              return ArrayFrom(v);
            }
            return null;
          };
        }
        var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
        var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
        function env(key) {
          return hasEnvVariables ? process.env[key] : void 0;
        }
        function getNativePromise() {
          if (typeof Promise === "function") {
            try {
              var promise = new Promise(function() {
              });
              if (classString(promise) === "[object Promise]") {
                return Promise;
              }
            } catch (e) {
            }
          }
        }
        var reflectHandler;
        function contextBind(ctx, cb) {
          if (ctx === null || typeof cb !== "function" || cb === reflectHandler) {
            return cb;
          }
          if (ctx.domain !== null) {
            cb = ctx.domain.bind(cb);
          }
          var async = ctx.async;
          if (async !== null) {
            var old = cb;
            cb = function() {
              var args = new Array(2).concat([].slice.call(arguments));
              ;
              args[0] = old;
              args[1] = this;
              return async.runInAsyncScope.apply(async, args);
            };
          }
          return cb;
        }
        var ret = {
          setReflectHandler: function(fn) {
            reflectHandler = fn;
          },
          isClass,
          isIdentifier,
          inheritedDataKeys,
          getDataPropertyOrDefault,
          thrower,
          isArray: es5.isArray,
          asArray,
          notEnumerableProp,
          isPrimitive,
          isObject,
          isError,
          canEvaluate,
          errorObj,
          tryCatch,
          inherits,
          withAppended,
          maybeWrapAsError,
          toFastProperties,
          filledRange,
          toString: safeToString,
          canAttachTrace,
          ensureErrorObject,
          originatesFromRejection,
          markAsOriginatingFromRejection,
          classString,
          copyDescriptors,
          isNode,
          hasEnvVariables,
          env,
          global: globalObject,
          getNativePromise,
          contextBind
        };
        ret.isRecentNode = ret.isNode && function() {
          var version;
          if (process.versions && process.versions.node) {
            version = process.versions.node.split(".").map(Number);
          } else if (process.version) {
            version = process.version.split(".").map(Number);
          }
          return version[0] === 0 && version[1] > 10 || version[0] > 0;
        }();
        ret.nodeSupportsAsyncResource = ret.isNode && function() {
          var supportsAsync = false;
          try {
            var res = _dereq_("async_hooks").AsyncResource;
            supportsAsync = typeof res.prototype.runInAsyncScope === "function";
          } catch (e) {
            supportsAsync = false;
          }
          return supportsAsync;
        }();
        if (ret.isNode)
          ret.toFastProperties(process);
        try {
          throw new Error();
        } catch (e) {
          ret.lastLineError = e;
        }
        module.exports = ret;
      }, { "./es5": 13, "async_hooks": void 0 }] }, {}, [4])(4);
    });
    if (typeof window !== "undefined" && window !== null) {
      window.P = window.Promise;
    } else if (typeof self !== "undefined" && self !== null) {
      self.P = self.Promise;
    }
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    function Buffer(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    function fromObject(obj2) {
      if (Buffer.isBuffer(obj2)) {
        var len = checked(obj2.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj2.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj2.length !== void 0) {
        if (typeof obj2.length !== "number" || numberIsNaN(obj2.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj2);
      }
      if (obj2.type === "Buffer" && Array.isArray(obj2.data)) {
        return fromArrayLike(obj2.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer.alloc(+length);
    }
    Buffer.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer.prototype;
    };
    Buffer.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer.from(b, b.offset, b.byteLength);
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer.prototype.toLocaleString = Buffer.prototype.toString;
    Buffer.prototype.equals = function equals(b) {
      if (!Buffer.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer.compare(this, b) === 0;
    };
    Buffer.prototype.inspect = function inspect() {
      var str = "";
      var max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    }
    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
      }
      if (!Buffer.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer.from(val, encoding);
      }
      if (Buffer.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret2 = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret2 += String.fromCharCode(buf[i] & 127);
      }
      return ret2;
    }
    function latin1Slice(buf, start, end) {
      var ret2 = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret2 += String.fromCharCode(buf[i]);
      }
      return ret2;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj2, type) {
      return obj2 instanceof type || obj2 != null && obj2.constructor != null && obj2.constructor.name != null && obj2.constructor.name === type.name;
    }
    function numberIsNaN(obj2) {
      return obj2 !== obj2;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require_buffer();
    var Buffer = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer.prototype);
    copyProps(Buffer, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "node_modules/jws/lib/data-stream.js"(exports2, module2) {
    var Buffer = require_safe_buffer().Buffer;
    var Stream = require_stream();
    var util = require_util();
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick((function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }).bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util.inherits(DataStream, Stream);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer.concat([this.buffer, Buffer.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module2.exports = DataStream;
  }
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "node_modules/buffer-equal-constant-time/index.js"(exports2, module2) {
    "use strict";
    var Buffer = require_buffer().Buffer;
    var SlowBuffer = require_buffer().SlowBuffer;
    module2.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports2, module2) {
    "use strict";
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module2.exports = getParamBytesForAlg;
  }
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports2, module2) {
    "use strict";
    var Buffer = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module2.exports = {
      derToJose,
      joseToDer
    };
  }
});

// node_modules/jwa/index.js
var require_jwa = __commonJS({
  "node_modules/jwa/index.js"(exports2, module2) {
    var bufferEqual = require_buffer_equal_constant_time();
    var Buffer = require_safe_buffer().Buffer;
    var crypto = require_crypto();
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require_util();
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj2) {
      return Buffer.isBuffer(obj2) || typeof obj2 === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer.from(signature), Buffer.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module2.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "node_modules/jws/lib/tostring.js"(exports2, module2) {
    var Buffer = require_buffer().Buffer;
    module2.exports = function toString(obj2) {
      if (typeof obj2 === "string")
        return obj2;
      if (typeof obj2 === "number" || Buffer.isBuffer(obj2))
        return obj2.toString();
      return JSON.stringify(obj2);
    };
  }
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "node_modules/jws/lib/sign-stream.js"(exports2, module2) {
    var Buffer = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require_stream();
    var toString = require_tostring();
    var util = require_util();
    function base64url(string, encoding) {
      return Buffer.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", (function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }).bind(this));
      this.payload.once("close", (function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }).bind(this));
    }
    util.inherits(SignStream, Stream);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module2.exports = SignStream;
  }
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "node_modules/jws/lib/verify-stream.js"(exports2, module2) {
    var Buffer = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require_stream();
    var toString = require_tostring();
    var util = require_util();
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject2(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject2(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", (function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }).bind(this));
      this.signature.once("close", (function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }).bind(this));
    }
    util.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj2 = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj2);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module2.exports = VerifyStream;
  }
});

// node_modules/jws/index.js
var require_jws = __commonJS({
  "node_modules/jws/index.js"(exports2) {
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports2.ALGORITHMS = ALGORITHMS;
    exports2.sign = SignStream.sign;
    exports2.verify = VerifyStream.verify;
    exports2.decode = VerifyStream.decode;
    exports2.isValid = VerifyStream.isValid;
    exports2.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports2.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// node_modules/jsonwebtoken-promisified/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/jsonwebtoken-promisified/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 1e4) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/jsonwebtoken-promisified/node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "node_modules/jsonwebtoken-promisified/node_modules/jsonwebtoken/lib/timespan.js"(exports2, module2) {
    var ms = require_ms();
    module2.exports = function(time) {
      var timestamp = Math.floor(Date.now() / 1e3);
      if (typeof time === "string") {
        var milliseconds = ms(time);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time === "number") {
        return timestamp + time;
      } else {
        return;
      }
    };
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports2, module2) {
    module2.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/jsonwebtoken-promisified/node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "node_modules/jsonwebtoken-promisified/node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports2, module2) {
    var JsonWebTokenError = function(message, error) {
      Error.call(this, message);
      Error.captureStackTrace(this, this.constructor);
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error)
        this.inner = error;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module2.exports = JsonWebTokenError;
  }
});

// node_modules/jsonwebtoken-promisified/node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "node_modules/jsonwebtoken-promisified/node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function(message, date) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module2.exports = NotBeforeError;
  }
});

// node_modules/jsonwebtoken-promisified/node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "node_modules/jsonwebtoken-promisified/node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module2.exports = TokenExpiredError;
  }
});

// node_modules/jsonwebtoken-promisified/node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "node_modules/jsonwebtoken-promisified/node_modules/jsonwebtoken/index.js"(exports2, module2) {
    var jws = require_jws();
    var ms = require_ms();
    var timespan = require_timespan();
    var xtend = require_immutable();
    var JWT = module2.exports;
    var JsonWebTokenError = JWT.JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = module2.exports.NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = JWT.TokenExpiredError = require_TokenExpiredError();
    JWT.decode = function(jwt, options) {
      options = options || {};
      var decoded = jws.decode(jwt, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj2 = JSON.parse(payload);
          if (typeof obj2 === "object") {
            payload = obj2;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
    var payload_options = [
      "expiresIn",
      "notBefore",
      "expiresInMinutes",
      "expiresInSeconds",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    JWT.sign = function(payload, secretOrPrivateKey, options, callback) {
      options = options || {};
      var header = {};
      if (typeof payload === "object") {
        header.typ = "JWT";
        payload = xtend(payload);
      } else {
        var invalid_option = payload_options.filter(function(key) {
          return typeof options[key] !== "undefined";
        })[0];
        if (invalid_option) {
          console.warn('invalid "' + invalid_option + '" option for ' + typeof payload + " payload");
        }
      }
      header.alg = options.algorithm || "HS256";
      if (options.headers) {
        Object.keys(options.headers).forEach(function(k) {
          header[k] = options.headers[k];
        });
      }
      var timestamp = Math.floor(Date.now() / 1e3);
      if (!options.noTimestamp) {
        payload.iat = payload.iat || timestamp;
      }
      if (typeof options.notBefore !== "undefined") {
        payload.nbf = timespan(options.notBefore);
        if (typeof payload.nbf === "undefined") {
          throw new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60');
        }
      }
      if (options.expiresInSeconds || options.expiresInMinutes) {
        var deprecated_line;
        try {
          deprecated_line = /.*\((.*)\).*/.exec(new Error().stack.split("\n")[2])[1];
        } catch (err) {
          deprecated_line = "";
        }
        console.warn("jsonwebtoken: expiresInMinutes and expiresInSeconds is deprecated. (" + deprecated_line + ')\nUse "expiresIn" expressed in seconds.');
        var expiresInSeconds = options.expiresInMinutes ? options.expiresInMinutes * 60 : options.expiresInSeconds;
        payload.exp = timestamp + expiresInSeconds;
      } else if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        payload.exp = timespan(options.expiresIn);
        if (typeof payload.exp === "undefined") {
          throw new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60');
        }
      }
      if (options.audience)
        payload.aud = options.audience;
      if (options.issuer)
        payload.iss = options.issuer;
      if (options.subject)
        payload.sub = options.subject;
      if (options.jwtid)
        payload.jti = options.jwtid;
      var encoding = "utf8";
      if (options.encoding) {
        encoding = options.encoding;
      }
      if (typeof callback === "function") {
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload: JSON.stringify(payload)
        }).on("done", callback);
      } else {
        return jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
      }
    };
    JWT.verify = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options)
        options = {};
      var done;
      if (callback) {
        done = function() {
          var args = Array.prototype.slice.call(arguments, 0);
          return process.nextTick(function() {
            callback.apply(null, args);
          });
        };
      } else {
        done = function(err, data) {
          if (err)
            throw err;
          return data;
        };
      }
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      var parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      if (parts[2].trim() === "" && secretOrPublicKey) {
        return done(new JsonWebTokenError("jwt signature is required"));
      }
      if (!secretOrPublicKey) {
        return done(new JsonWebTokenError("secret or public key must be provided"));
      }
      if (!options.algorithms) {
        options.algorithms = ~secretOrPublicKey.toString().indexOf("BEGIN CERTIFICATE") || ~secretOrPublicKey.toString().indexOf("BEGIN PUBLIC KEY") ? ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512"] : ~secretOrPublicKey.toString().indexOf("BEGIN RSA PUBLIC KEY") ? ["RS256", "RS384", "RS512"] : ["HS256", "HS384", "HS512"];
      }
      var decodedToken;
      try {
        decodedToken = jws.decode(jwtString);
      } catch (err) {
        return done(new JsonWebTokenError("invalid token"));
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      var header = decodedToken.header;
      if (!~options.algorithms.indexOf(header.alg)) {
        return done(new JsonWebTokenError("invalid algorithm"));
      }
      var valid;
      try {
        valid = jws.verify(jwtString, header.alg, secretOrPublicKey);
      } catch (e) {
        return done(e);
      }
      if (!valid)
        return done(new JsonWebTokenError("invalid signature"));
      var payload;
      try {
        payload = JWT.decode(jwtString);
      } catch (err) {
        return done(err);
      }
      if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
        if (typeof payload.nbf !== "number") {
          return done(new JsonWebTokenError("invalid nbf value"));
        }
        if (payload.nbf > Math.floor(Date.now() / 1e3)) {
          return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
        }
      }
      if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
        if (typeof payload.exp !== "number") {
          return done(new JsonWebTokenError("invalid exp value"));
        }
        if (Math.floor(Date.now() / 1e3) >= payload.exp)
          return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
      }
      if (options.audience) {
        var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
        var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
        var match = target.some(function(aud) {
          return audiences.indexOf(aud) != -1;
        });
        if (!match)
          return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
      }
      if (options.issuer) {
        var invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
        if (invalid_issuer) {
          return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
        }
      }
      if (options.subject) {
        if (payload.sub !== options.subject) {
          return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
        }
      }
      if (options.jwtid) {
        if (payload.jti !== options.jwtid) {
          return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
        }
      }
      if (options.maxAge) {
        var maxAge = ms(options.maxAge);
        if (typeof payload.iat !== "number") {
          return done(new JsonWebTokenError("iat required when maxAge is specified"));
        }
        if (Date.now() - payload.iat * 1e3 > maxAge) {
          return done(new TokenExpiredError("maxAge exceeded", new Date(payload.iat * 1e3 + maxAge)));
        }
      }
      return done(null, payload);
    };
  }
});

// node_modules/promisify-simple-callback/lib/index.js
var require_lib = __commonJS({
  "node_modules/promisify-simple-callback/lib/index.js"(exports2, module2) {
    "use strict";
    var Promise2 = require_bluebird();
    module2.exports = function(method) {
      var defaults = arguments.length <= 1 || arguments[1] === void 0 ? [] : arguments[1];
      return function() {
        var _this = this;
        var originalArgs = new Array(arguments.length);
        for (var i = 0; i < originalArgs.length; ++i) {
          originalArgs[i] = arguments[i];
        }
        return new Promise2(function(resolve, reject) {
          var args = new Array(Math.max(originalArgs.length, defaults.length) + 1);
          for (var i2 = 0; i2 < originalArgs.length; ++i2) {
            args[i2] = originalArgs[i2];
          }
          if (originalArgs.length < defaults.length) {
            for (var i2 = originalArgs.length; i2 < defaults.length; i2++) {
              if (defaults[i2] != null) {
                args[i2] = defaults[i2];
              }
            }
          }
          args[args.length - 1] = function(result) {
            resolve(result);
          };
          method.apply(_this, args);
        });
      };
    };
  }
});

// node_modules/promisify-simple-callback/index.js
var require_promisify_simple_callback = __commonJS({
  "node_modules/promisify-simple-callback/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_lib();
  }
});

// node_modules/jsonwebtoken-promisified/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/jsonwebtoken-promisified/lib/index.js"(exports2, module2) {
    "use strict";
    var Promise2 = require_bluebird();
    var jwt = require_jsonwebtoken();
    var promisifySimpleCallback = require_promisify_simple_callback();
    jwt.signAsync = promisifySimpleCallback(jwt.sign, [null, null, {}]);
    jwt.verifyAsync = Promise2.promisify(jwt.verify);
    module2.exports = jwt;
  }
});

// node_modules/jsonwebtoken-promisified/index.js
var require_jsonwebtoken_promisified = __commonJS({
  "node_modules/jsonwebtoken-promisified/index.js"(exports2, module2) {
    module2.exports = require_lib2();
  }
});
export default require_jsonwebtoken_promisified();
/*! Bundled license information:

bluebird/js/browser/bluebird.js:
  (* @preserve
   * The MIT License (MIT)
   * 
   * Copyright (c) 2013-2018 Petka Antonov
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   * 
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=jsonwebtoken-promisified.js.map
